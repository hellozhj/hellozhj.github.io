<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="interview, Evedward">
    <meta name="description" content="面试HTML
简述Chome盒模型与IE盒模型的区别：Chome：内容 = content
IE：内容 = content + padding + border

行内元素：&amp;lt;span&amp;gt;、&amp;lt;a&amp;gt;、&amp;lt;b&amp;gt;、">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>interview | Evedward</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Evedward" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Evedward</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Evedward</div>
        <div class="logo-desc">
            
            关注嘉然，顿顿解馋
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/hellozhj" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/hellozhj" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">interview</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-08-05
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    27.8k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><hr>
<h4 id="简述Chome盒模型与IE盒模型的区别："><a href="#简述Chome盒模型与IE盒模型的区别：" class="headerlink" title="简述Chome盒模型与IE盒模型的区别："></a>简述Chome盒模型与IE盒模型的区别：</h4><p>Chome：内容 = content</p>
<p>IE：内容 = content + padding + border</p>
<hr>
<h4 id="行内元素："><a href="#行内元素：" class="headerlink" title="行内元素："></a>行内元素：</h4><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">&gt;</span></span></code></pre>

<h4 id="行内块元素："><a href="#行内块元素：" class="headerlink" title="行内块元素："></a>行内块元素：</h4><pre class="language-html" data-language="html"><code class="language-html">img、textarea、input、button、select、td、th</code></pre>

<h4 id="块级元素："><a href="#块级元素：" class="headerlink" title="块级元素："></a>块级元素：</h4><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>center</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">&gt;</span></span></code></pre>

<hr>
<h4 id="BFC：块级格式化上下文，"><a href="#BFC：块级格式化上下文，" class="headerlink" title="BFC：块级格式化上下文，"></a>BFC：块级格式化上下文，</h4><p>流体特征：块级水平元素，水平方向自动填充外部容器，内部子元素不会影响到外部的元素</p>
<p>©</p>
<blockquote>
<p>body 根元素</p>
<p>浮动元素：float 除 none 以外的值</p>
<p>绝对定位元素：position (absolute、fixed)</p>
<p>display 为 inline-block、table-cells、flex</p>
<p>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
</blockquote>
<hr>
<h4 id="什么是弹性布局："><a href="#什么是弹性布局：" class="headerlink" title="什么是弹性布局："></a>什么是弹性布局：</h4><p>解决 子元素 布局方法，提供最大的灵活性，子元素<code>float、clear、vertical-align</code>失效，<code>align-self</code>定义子元素的位置</p>
<hr>
<h4 id="html5-的新特性："><a href="#html5-的新特性：" class="headerlink" title="html5 的新特性："></a>html5 的新特性：</h4><blockquote>
<p>1.Canvas </p>
<p>2.SVG 绘图</p>
<p>3.地理定位</p>
<p>4.Web worker(运行在后台的js)</p>
<p>5.web Storage(cookie，sessionStorage，localStorage)</p>
<p>6.Web Socket(全双工通信，服务器主动→客户端)</p>
</blockquote>
<hr>
<h4 id="position有哪些属性？7个"><a href="#position有哪些属性？7个" class="headerlink" title="position有哪些属性？7个"></a>position有哪些属性？7个</h4><hr>
<h4 id="请说出1px，1rem，1vh，1em各自代表的含义？"><a href="#请说出1px，1rem，1vh，1em各自代表的含义？" class="headerlink" title="请说出1px，1rem，1vh，1em各自代表的含义？"></a>请说出1px，1rem，1vh，1em各自代表的含义？</h4><p>px：像素，相对屏幕分辨率</p>
<p>em：相对于当前对象→相对(继承)父级元素字体大小→相对于浏览器默认</p>
<p>rem：相对于根 html 元素(字体大小)，其他元素rem</p>
<p>vw/vh：相当于屏幕的宽度和高度的 1%，宽度用%，高度vh</p>
<hr>
<h4 id="什么是SPA？"><a href="#什么是SPA？" class="headerlink" title="什么是SPA？"></a>什么是SPA？</h4><p>单页面web应用。加载单个HTML页面，只在页面初始化加载相应的html，js，css。不会因为用户的操作，进行页面的重新加载跳转，利用js动态的切换html元素。UI用户交互。展示逻辑先加载，利于内容的切换。</p>
<p>优点：前后端的分离；</p>
<p>缺点：不利于SEO，首页加载相对慢，导航不可用</p>
<hr>
<h4 id="简述优雅降级与渐进增强："><a href="#简述优雅降级与渐进增强：" class="headerlink" title="简述优雅降级与渐进增强："></a>简述优雅降级与渐进增强：</h4><p>优雅降级：构建完整的功能，对低版本浏览器进行兼容；复杂开始，减少用户体验(针对高级完善的浏览器)</p>
<p>渐进增强：低版本构建页面，保证基本功能，对高级浏览器交互改进追加功能；基础开始，不断扩充，适应需要。(关注内容本身)</p>
<hr>
<h4 id="重绘与重排："><a href="#重绘与重排：" class="headerlink" title="重绘与重排："></a>重绘与重排：</h4><p>1.重绘：元素外观改变，浏览器重新绘制，常见：background，visibility，outline</p>
<p>2.重排：渲染树重新计算，常见：几何属性，节点，offset，client系列，改浏览器大小</p>
<p>区别：1.重绘不一定重排。<strong>重绘不一定需要重排（比如颜色的改变），重排必然导致重绘</strong>（比如改变网页位置）</p>
<p>减小重排：</p>
<blockquote>
<p>1.样式修改，多次合一次</p>
<p>2.多次重排，<code>position</code>为ab，fixed，脱离文档流</p>
<p>3.内存操作节点，完成再添加文档</p>
<p>4.复杂操作，可以将其display属性设置为none使其隐藏</p>
</blockquote>
<hr>
<h4 id="解释下浮动和它的工作原理？清除浮动的方法"><a href="#解释下浮动和它的工作原理？清除浮动的方法" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的方法"></a>解释下浮动和它的工作原理？清除浮动的方法</h4><p>浮动：脱离文档流，不占空间，父级边界或者同级浮动元素停留(遇到两种)</p>
<p>清除浮动的方法：</p>
<blockquote>
<p>1.浮动元素后面空标签：clear:both，(有弊端)</p>
<p>2.父元素超出隐藏</p>
<p>3.<code>after</code>伪元素</p>
<p>4.浮动外部(父)元素</p>
</blockquote>
<hr>
<h4 id="盒子页面水平居中"><a href="#盒子页面水平居中" class="headerlink" title="盒子页面水平居中"></a>盒子页面水平居中</h4><p>已知宽高：定位，四个0，margin：auto</p>
<p>未知宽高：定位，两50%，两个-50%</p>
<hr>
<h4 id="前端性能优化方案："><a href="#前端性能优化方案：" class="headerlink" title="前端性能优化方案："></a>前端性能优化方案：</h4><blockquote>
<p>1.dom操作少</p>
<p>2.http请求少</p>
<p>3.js优化，冗余代码少</p>
<p>4.代码，图片，资源压缩</p>
<p>5.缓存</p>
<p>6.cdn加速</p>
</blockquote>
<hr>
<h4 id="css选择器优先级顺序"><a href="#css选择器优先级顺序" class="headerlink" title="css选择器优先级顺序"></a>css选择器优先级顺序</h4><p>7种：#id；.class；属性；伪类；伪元素；标签；*；</p>
<hr>
<h4 id="css3的新特性："><a href="#css3的新特性：" class="headerlink" title="css3的新特性："></a>css3的新特性：</h4><p>圆角，阴影，文字阴影，线性渐变，旋转缩放移动倾斜，缩放，位移，媒体查询，多栏布局，背景</p>
<hr>
<h4 id="空元素：内容：br，meta，hr，link，input，img"><a href="#空元素：内容：br，meta，hr，link，input，img" class="headerlink" title="空元素：内容：br，meta，hr，link，input，img"></a>空元素：内容：br，meta，hr，link，input，img</h4><hr>
<h4 id="如何实现浏览器内多个标签页之间的通讯："><a href="#如何实现浏览器内多个标签页之间的通讯：" class="headerlink" title="如何实现浏览器内多个标签页之间的通讯："></a>如何实现浏览器内多个标签页之间的通讯：</h4><p>1.定时器+cookie；使用定时器刷新，检查cookie(同域可读)是否被修改(浪费资源)</p>
<p>2.<code>localstorage</code>:非当前页面修改<code>localstorage</code>时触发。<strong>事件监听</strong></p>
<p>(ps：session是会话级的存储空间，每个标签页都是单独的）。</p>
<hr>
<h4 id="为什么要初始化css样式："><a href="#为什么要初始化css样式：" class="headerlink" title="为什么要初始化css样式："></a>为什么要初始化css样式：</h4><p>1.浏览器差异，标签默认值不同</p>
<p>2.提高编码质量</p>
<hr>
<h4 id="css3新增的伪类有那些-5"><a href="#css3新增的伪类有那些-5" class="headerlink" title="css3新增的伪类有那些:5"></a>css3新增的伪类有那些:5</h4><hr>
<h4 id="对canvas，svg，webgl的理解："><a href="#对canvas，svg，webgl的理解：" class="headerlink" title="对canvas，svg，webgl的理解："></a>对<code>canvas</code>，<code>svg</code>，<code>webgl</code>的理解：</h4><p>1.h5新增加元素对象，画布，js有api，2d，不依赖，高数据帧率</p>
<p>2.<code>SVG</code>给数据可以绘制点，线，图，基于XML标记语言，矢量图，底数据帧率，图形图表</p>
<p>3.<code>WebGL</code>，3d绘图，第三方库three.js</p>
<hr>
<h4 id="浏览器如何渲染UI？"><a href="#浏览器如何渲染UI？" class="headerlink" title="浏览器如何渲染UI？"></a>浏览器如何渲染UI？</h4><p>1.html，解析，DOM树</p>
<p>2.css，解析，规则</p>
<p>3.dom树 + css规则 = 渲染树</p>
<p>4.布局阶段，节点，页面定位</p>
<p>5.GPU  遍历渲染树节点，元素呈现</p>
<hr>
<h4 id="em、rem区别："><a href="#em、rem区别：" class="headerlink" title="em、rem区别："></a>em、rem区别：</h4><p>em：相对于当前对象→相对(继承)父级元素字体大小→相对于浏览器默认</p>
<p>rem：相对于根元素HTML的字体大小</p>
<hr>
<h4 id="解释cssprites-精灵图-如可使用："><a href="#解释cssprites-精灵图-如可使用：" class="headerlink" title="解释cssprites(精灵图)如可使用："></a>解释cssprites(精灵图)如可使用：</h4><p>小图整合到大图上减少图片的字节，减轻服务器图片数量请求，<strong>background背景定位技术技巧布局网页背景</strong></p>
<pre class="language-js" data-language="js"><code class="language-js">background<span class="token operator">-</span>position<span class="token operator">:</span> <span class="token operator">-</span>480px <span class="token operator">-</span>558px<span class="token punctuation">;</span></code></pre>

<hr>
<h4 id="伪类和伪元素的区别："><a href="#伪类和伪元素的区别：" class="headerlink" title="伪类和伪元素的区别："></a>伪类和伪元素的区别：</h4><p>伪类：</p>
<blockquote>
<p>选择dom树之外的信息，普通选择器不能选择，添加选择器特殊效果</p>
<p>:hover	:active	:visited	:link	:visited	:first-child	:focus	:lang 等</p>
<p>状态变化，到达一定状态得到伪类样式</p>
<p>基于文档外的抽象</p>
</blockquote>
<p>伪元素：</p>
<blockquote>
<p>dom树未定义的虚拟元素</p>
<p>创建不在文档中的元素</p>
<p>::before 和 ::after 指定元素内容的前后</p>
<p>基于元素的抽象，不在文档中，特殊效果添加到选择器中</p>
</blockquote>
<p>区别：</p>
<blockquote>
<p>css2都是：表示</p>
<p>css3:伪元素::，伪类:</p>
<p>定义：伪类：假的类，添加类；伪元素：假的元素，添加元素</p>
</blockquote>
<p>相同：</p>
<blockquote>
<p>都是dom树以外的元素，不在源文件中</p>
<p>伪类基于dom元素产生不同状态，dom某一特征</p>
<p>伪元素创建dom不存在的抽象对象，可以访问到</p>
</blockquote>
<p><strong>总结：</strong> 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p>
<hr>
<h4 id="浏览器的工作原理：7"><a href="#浏览器的工作原理：7" class="headerlink" title="浏览器的工作原理：7"></a>浏览器的工作原理：7</h4><p>1.用户界面；2.浏览器引擎；3.数据存储；4.渲染引擎；5.网络；6.js解释器；7.UI后端</p>
<img src="/2022/08/05/interview/v2-acb485cbc3d3e140e4ed7863d776abdb_720w.jpg" alt="img" style="zoom:80%;">

<hr>
<h4 id="浏览器内核的理解："><a href="#浏览器内核的理解：" class="headerlink" title="浏览器内核的理解："></a>浏览器内核的理解：</h4><p>渲染引擎：获得网页内容html等，整理，计算页面显示，输出；不同内核不同网页语法，渲染效果不同</p>
<p>JS引擎：解析执行js，实现动效，独立出来</p>
<hr>
<h4 id="常见的浏览器内核：4"><a href="#常见的浏览器内核：4" class="headerlink" title="常见的浏览器内核：4"></a>常见的浏览器内核：4</h4><p>trident：ie；Gecko；Presto；Webkit：谷歌</p>
<hr>
<h4 id="一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验："><a href="#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验：" class="headerlink" title="一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验："></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验：</h4><blockquote>
<p>1.图片懒加载</p>
<p>2.图片预加载(幻灯片，相册)</p>
<p>3.缩略图</p>
<p>（4）如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p>
</blockquote>
<hr>
<h4 id="seo优化："><a href="#seo优化：" class="headerlink" title="seo优化："></a>seo优化：</h4><blockquote>
<p>1.合理title(重点)、descript(概括)、keywords(关键字)，权重减小，</p>
<p>2.语义化，搜索引擎理解</p>
<p>3.搜索引擎上到下，重要html内容在前面，被抓取</p>
<p>4.重要内容不要js输出，爬不到js内容</p>
<p>5.少用 iframe</p>
<p>6.非修饰图片加alt</p>
<p>7.提高网站速度</p>
</blockquote>
<hr>
<h4 id="实现0-5px边框：3"><a href="#实现0-5px边框：3" class="headerlink" title="实现0.5px边框：3"></a>实现0.5px边框：3</h4><ol>
<li><strong>border+border-image+linear-gradient的方式</strong></li>
<li><strong>伪元素+background-image的方式</strong></li>
<li><strong>定位+伪元素+transfrom缩放(scale)的方式</strong></li>
</ol>
<hr>
<h4 id="less-和-sass-的区别："><a href="#less-和-sass-的区别：" class="headerlink" title="less 和 sass 的区别："></a>less 和 sass 的区别：</h4><p>less：基于js，客户端处理；<code>@</code>；没有输出设置；不支持条件语句</p>
<p>sass：基于ruby，服务器处理；<code>$</code>；4种输出选项(nested，compact，compressed，expanded)；支持条件语句(if,else)<code>for()</code>循环</p>
<hr>
<h4 id="了解-xhtml和html有什么区别"><a href="#了解-xhtml和html有什么区别" class="headerlink" title="(了解)xhtml和html有什么区别:"></a>(了解)xhtml和html有什么区别:</h4><p>功能：xhtml 兼容各大浏览器，手机，pda，</p>
<p>书写：xhtml语法更严谨</p>
<ol>
<li>标签小写；</li>
<li>标签成对；</li>
<li>标签顺序，先进后出；</li>
<li>所有属性使用双引号；</li>
<li>不允许使用target=”_blank”(改写为rel=”external”，并搭配JavaScript实现此效果)</li>
</ol>
<hr>
<h4 id="了解-img标签上title与alt属性的区别是什么"><a href="#了解-img标签上title与alt属性的区别是什么" class="headerlink" title="(了解)img标签上title与alt属性的区别是什么?"></a>(了解)img标签上title与alt属性的区别是什么?</h4><p>title：为该属性提供信息</p>
<p>alt：当图片不显示是用文字代表</p>
<hr>
<h4 id="了解-a标签中-active-hover-link-visited-正确的设置顺序是什么"><a href="#了解-a标签中-active-hover-link-visited-正确的设置顺序是什么" class="headerlink" title="(了解)a标签中 active hover link visited 正确的设置顺序是什么?"></a>(了解)a标签中 active hover link visited 正确的设置顺序是什么?</h4><p>lvha</p>
<hr>
<h4 id="了解-什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？"><a href="#了解-什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？" class="headerlink" title="(了解)什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？"></a>(了解)什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？</h4><p>FOUC(Flash Of Unstyled Content)–文档样式闪烁</p>
<p>ie先加载html文档的dom，再导入外部css，中间一段时间没有样式。</p>
<p>解决方法：<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素</p>
<hr>
<h4 id="了解-如何处理HTML5新标签的浏览器兼容性问题"><a href="#了解-如何处理HTML5新标签的浏览器兼容性问题" class="headerlink" title="(了解)如何处理HTML5新标签的浏览器兼容性问题"></a>(了解)如何处理HTML5新标签的浏览器兼容性问题</h4><p>法一：js 新增标签(创建出来的是内联元素，转块级和给宽高)</p>
<p>法二：静态资源 html5shiv 包。载入后，初始化新标签的css</p>
<hr>
<h4 id="了解-HTML5的离线储存怎么使用，工作原理能不能解析一下？"><a href="#了解-HTML5的离线储存怎么使用，工作原理能不能解析一下？" class="headerlink" title="(了解)HTML5的离线储存怎么使用，工作原理能不能解析一下？"></a>(了解)HTML5的离线储存怎么使用，工作原理能不能解析一下？</h4><hr>
<h4 id="了解-页面导入样式时，使用link和-import有什么区别"><a href="#了解-页面导入样式时，使用link和-import有什么区别" class="headerlink" title="(了解)页面导入样式时，使用link和@import有什么区别"></a>(了解)页面导入样式时，使用link和@import有什么区别</h4><p>link：XHTML标签，加载css还用于定义rss，rel链接属性。页面加载时，link同时加载。没有兼容问题。支持js修改样式</p>
<p>@import：属于css提供，加载css。页面加载完，css后加载。ie5以上才能被识别。不支持js修改样式</p>
<hr>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><hr>
<h4 id="严格模式：-代码，严格解析，错误处理"><a href="#严格模式：-代码，严格解析，错误处理" class="headerlink" title="严格模式： 代码，严格解析，错误处理"></a>严格模式： 代码，严格解析，错误处理</h4><blockquote>
<p>优点：</p>
<p>1.消除，语法，不合理，不严谨，怪异行为</p>
<p>2.消除，不安全，安全</p>
<p>3.效率，速度</p>
<p>4.铺垫</p>
</blockquote>
<blockquote>
<p>缺点：压缩，”use strict” 文件中间，浪费字节</p>
</blockquote>
<hr>
<h4 id="console-log-0-1-0-2-x3D-0-3-：二进制相加，超52位，精确"><a href="#console-log-0-1-0-2-x3D-0-3-：二进制相加，超52位，精确" class="headerlink" title="console.log(0.1+0.2) != 0.3 ? ：二进制相加，超52位，精确"></a>console.log(0.1+0.2) != 0.3 ? ：二进制相加，超52位，精确</h4><hr>
<h4 id="pop-push-unshift-shift-的区别"><a href="#pop-push-unshift-shift-的区别" class="headerlink" title="pop(), push(), unshift(), shift()的区别"></a>pop(), push(), unshift(), shift()的区别</h4><hr>
<h4 id="和-区别"><a href="#和-区别" class="headerlink" title="== 和 ===区别"></a><code>==</code> 和 <code>===</code>区别</h4><hr>
<h4 id="事件冒泡和事件捕获区别？"><a href="#事件冒泡和事件捕获区别？" class="headerlink" title="事件冒泡和事件捕获区别？"></a>事件冒泡和事件捕获区别？</h4><p>事件冒泡：下至上，父子元素，同一事件</p>
<p>事件捕获：上至下，指定元素，传递</p>
<hr>
<h4 id="ES5的时候，数据类型：七"><a href="#ES5的时候，数据类型：七" class="headerlink" title="ES5的时候，数据类型：七"></a>ES5的时候，数据类型：七</h4><p><strong>Number、String、Boolean、undefined、object、Null。</strong></p>
<p><strong>Symbol</strong> ：类型对象不相等，始创建传入相同值，属性名冲突，标记</p>
<hr>
<h4 id="什么是typescript："><a href="#什么是typescript：" class="headerlink" title="什么是typescript："></a>什么是typescript：</h4><p>1.超集，可选的静态类型，类，面向对象</p>
<p>2.扩展，大型，兼容</p>
<hr>
<h4 id="模块化编程：内部，module变量，exports接口"><a href="#模块化编程：内部，module变量，exports接口" class="headerlink" title="模块化编程：内部，module变量，exports接口"></a>模块化编程：内部，module变量，exports接口</h4><hr>
<h4 id="简述javascript原型："><a href="#简述javascript原型：" class="headerlink" title="简述javascript原型："></a>简述javascript原型：</h4><p>构造函数，prototype，指向</p>
<p>原型链：<code>__proto__</code>，属性方法，指向原型链最终端<code>null</code>，串</p>
<p>有什么特点：1.继承，2.构造→原型；2.原型→构造，3.构造→实例，4.实例→原型</p>
<hr>
<h4 id="javascript中的作用域："><a href="#javascript中的作用域：" class="headerlink" title="javascript中的作用域："></a>javascript中的作用域：</h4><p>定义变量的区域，规定如何查找变量，访问全选</p>
<p>变量声明提升：声明(变和函)，</p>
<p>在 JavaScript 中，每个函数都有自己的作用域。作用域基本上是变量以及如何通过名称访问这些变量的规则的集合。只有函数中的代码才能访问函数作用域内的变量。</p>
<p>同一个作用域中的变量名必须是唯一的。一个作用域可以嵌套在另一个作用域内。如果一个作用域嵌套在另一个作用域内，最内部作用域内的代码可以访问另一个作用域的变量。</p>
<hr>
<h4 id="this对象的理解："><a href="#this对象的理解：" class="headerlink" title="this对象的理解："></a>this对象的理解：</h4><p>call()和apply()区别：传参不同，函数体内this，apply:带下标的集合，call:不固定的；call传参格式内部需要，性能好</p>
<hr>
<h4 id="js-的typeof返回几种数据类型：7"><a href="#js-的typeof返回几种数据类型：7" class="headerlink" title="js 的typeof返回几种数据类型：7"></a>js 的typeof返回几种数据类型：7</h4><pre class="language-js" data-language="js"><code class="language-js">string，number，Boolean，<span class="token keyword">undefined</span>，object，<span class="token keyword">function</span><span class="token punctuation">,</span> <span class="token function">symbol</span><span class="token punctuation">(</span>es6<span class="token punctuation">)</span></code></pre>

<hr>
<h4 id="闭包：函数执行，返回函数，外部变量引用，持被执行函数变量"><a href="#闭包：函数执行，返回函数，外部变量引用，持被执行函数变量" class="headerlink" title="闭包：函数执行，返回函数，外部变量引用，持被执行函数变量"></a>闭包：函数执行，返回函数，外部变量引用，持被执行函数变量</h4><blockquote>
<p>读取函数内变量</p>
<p>内存，不污染，内存消耗，性能，内存泄漏，释放内存null</p>
</blockquote>
<blockquote>
<p>闭包的原理：函数执行两个阶段(预编译阶段和执行阶段)闭包对象</p>
<p>函数作用域链的特性：</p>
</blockquote>
<blockquote>
<p>优点：内部函数访问外部，变量。免污染。私有成员</p>
<p>缺点：内存消耗，无法垃圾回收，使用量，泄漏。处理速度，作用域链的长度。得到以外的值</p>
</blockquote>
<blockquote>
<p>应用场景： 1.模块封装。2.循环中创建闭包，防止拿到意外值</p>
</blockquote>
<hr>
<h4 id="简述js继承的方式："><a href="#简述js继承的方式：" class="headerlink" title="简述js继承的方式："></a>简述js继承的方式：</h4><ul>
<li><strong>混入式：父类的方法都拷贝到子类</strong></li>
<li><strong>原型式：只继承父类原型的属性和方法</strong></li>
<li><strong>原型链：继承父类构造函数和原型的属性和方法，不能传参</strong></li>
<li><strong>构造函数：继承父类构造函数属性和方法，可以传参，不能原型</strong></li>
<li><strong>组合：构造函数继承 + 原型链继承</strong></li>
</ul>
<hr>
<h4 id="给String添加一个trim-方法、去除开头和结尾的空格符号："><a href="#给String添加一个trim-方法、去除开头和结尾的空格符号：" class="headerlink" title="给String添加一个trim()方法、去除开头和结尾的空格符号："></a>给String添加一个trim()方法、去除开头和结尾的空格符号：</h4><p><strong>在它原型对象上<code>replace</code>&amp;&amp;正则</strong></p>
<hr>
<h4 id="深拷贝和浅拷贝的区别："><a href="#深拷贝和浅拷贝的区别：" class="headerlink" title="深拷贝和浅拷贝的区别："></a>深拷贝和浅拷贝的区别：</h4><blockquote>
<p>浅拷贝：添加新指针，已存在内存</p>
<p>浅复制：指向内存地址，原改变，也改变</p>
<p>深拷贝：新指针，新内存</p>
<p>深复制：新内存地址，原改变，不改变</p>
</blockquote>
<hr>
<h4 id="如何实现深拷贝："><a href="#如何实现深拷贝：" class="headerlink" title="如何实现深拷贝："></a>如何实现深拷贝：</h4><ul>
<li>序列化，存磁盘，反序列化</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>缺点：忽略undefined，symbol，function</p>
<ul>
<li>递归+判断类型 (数字 字符串 function是不需要拷贝的)</li>
</ul>
<hr>
<h4 id="javascript-的垃圾回收机制："><a href="#javascript-的垃圾回收机制：" class="headerlink" title="javascript 的垃圾回收机制："></a>javascript 的垃圾回收机制：</h4><p>释放内存：释放所有不再使用的内存，使之成为自由内存，并可以被重新利用</p>
<p>垃圾：内存，没使用，没回收，浏览器结束；</p>
<p>垃圾收集：创建→释放</p>
<p>内存生命周期：系统分配(高级)，使用(变量)，释放(高级)</p>
<p>算法策略：标记清除，标记整理，引用计数，分代</p>
<p>内存泄漏：全局变量(没有var)，(忘)定时器回调函数，闭包，dom引用没清理，计时器(字符串参数)，控制台日志，两个对象彼此引用保留(循环)</p>
<hr>
<h4 id="介绍下-promise-的特性、优缺点："><a href="#介绍下-promise-的特性、优缺点：" class="headerlink" title="介绍下 promise 的特性、优缺点："></a>介绍下 promise 的特性、优缺点：</h4><p>特征：解决异步请求回调地狱</p>
<blockquote>
<p>1.三种状态（pending，fulfilled，rejected）</p>
<p>2.回调函数参数，resolve(成功执行then方法，实例)，reject(失败执行catch方法，error实例)</p>
<p>3.then(接收两个参数，是状态的回调)和catch方法返回一个新的 Promise实例</p>
<p>4.finally方法，没参数</p>
<p>5.all方法，参数是多个promise实例(数组)，一个触发catch，本身就调用了catch</p>
<p>6.race方法，一个状态改变，就返回(谁快就是谁)</p>
</blockquote>
<p>优点：</p>
<blockquote>
<p>1.作用于浏览器，统一异步的api</p>
<p>2.Promise 更适合处理一次性的结果，链式处理</p>
<p>3.回调地狱，异步代码同步化</p>
<p>4.异常处理方式</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1.无法中途取消</p>
<p>2.不设置回调会出错</p>
<p>3.pending不知进展阶段</p>
</blockquote>
<hr>
<h4 id="XMLhttprequest对象：ajax核心，支持异步请求，js请求响应，局部更新"><a href="#XMLhttprequest对象：ajax核心，支持异步请求，js请求响应，局部更新" class="headerlink" title="XMLhttprequest对象：ajax核心，支持异步请求，js请求响应，局部更新"></a>XMLhttprequest对象：ajax核心，支持异步请求，js请求响应，局部更新</h4><hr>
<h4 id="cookies，sessionStorage-和-localStorage-的区别？"><a href="#cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="cookies，sessionStorage 和 localStorage 的区别？"></a><code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h4><blockquote>
<p>cookies：浏览器自动携带请求，体积小，后端设置，前端修改不了，设置过期时间，做状态保存，浏览器第一次访问服务器给，第二次请求携带</p>
<p>sessionStorage：服务器内存中，关闭浏览器</p>
<p>localStorage：关闭浏览器不消失，手动</p>
</blockquote>
<hr>
<h4 id="浏览器缓存策略：强制缓存和协商缓存，强缓优先于协商缓存。"><a href="#浏览器缓存策略：强制缓存和协商缓存，强缓优先于协商缓存。" class="headerlink" title="浏览器缓存策略：强制缓存和协商缓存，强缓优先于协商缓存。"></a>浏览器缓存策略：强制缓存和协商缓存，强缓优先于协商缓存。</h4><ul>
<li>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</li>
<li>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li>
</ul>
<p><img src="/2022/08/05/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt="浏览器的缓存策略"></p>
<hr>
<h4 id="同源策略与跨域："><a href="#同源策略与跨域：" class="headerlink" title="同源策略与跨域："></a>同源策略与跨域：</h4><p>同源是约定，浏览器安全功能；跨域：协议，域名，端口</p>
<hr>
<h4 id="跨域解决方案："><a href="#跨域解决方案：" class="headerlink" title="跨域解决方案："></a>跨域解决方案：</h4><p>后端：cors，代理；前端：JSONP，利用script标签跨域</p>
<hr>
<h4 id="从浏览器地址栏输入URL到显示页面的步骤："><a href="#从浏览器地址栏输入URL到显示页面的步骤：" class="headerlink" title="从浏览器地址栏输入URL到显示页面的步骤："></a>从浏览器地址栏输入URL到显示页面的步骤：</h4><blockquote>
<p>1.dns，ip</p>
<p>2.响应数据，html</p>
<p>3.语法解析，dom结构</p>
<p>4.渲染</p>
</blockquote>
<hr>
<h4 id="JavaScript-中的作用域："><a href="#JavaScript-中的作用域：" class="headerlink" title="JavaScript 中的作用域："></a>JavaScript 中的作用域：</h4><p>变量唯一，嵌套，内存访问外层</p>
<hr>
<h4 id="解释-JavaScript-中的-null-和-undefined："><a href="#解释-JavaScript-中的-null-和-undefined：" class="headerlink" title="解释 JavaScript 中的 null 和 undefined："></a>解释 JavaScript 中的 null 和 undefined：</h4><p>null：空对象</p>
<p>undefined：null派生，声明未赋值</p>
<hr>
<h4 id="浏览器的事件循环："><a href="#浏览器的事件循环：" class="headerlink" title="浏览器的事件循环："></a>浏览器的事件循环：</h4><p>同步和异步，同步执行，放到主线程上排队执行；异步放到任务队列里面，有多个异步代码在队列里面排队等待，类似缓存区，任务下一步移到调用栈，主线程执行调用栈。调用栈是否为空或者某个任务添加到调用栈里面就是一个事件循环。</p>
<p>可以看成是宏任务和微任务，先执行宏任务里面同步代码，移到宏任务队列，后执行微任务队列，再执行宏任务队列。</p>
<hr>
<h4 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h4><p>怎么阻止事件冒泡： event.cancelBubble 或 event.stopPropagation()</p>
<hr>
<h4 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h4><p>防抖：进行某个行为，一段时间内，没有行为，才响应给用户。</p>
<p>实现原理：每次触发事件，都触发延时调用，取消之前的延迟调用</p>
<p>节流：高频事件触发，限制在一段时间内只执行一次</p>
<p>实现原理：变量，控制一段代码，一时间内只执行一次</p>
<p>区别：节流：保证一定时间内都会执行，防抖：最后一次触发，执行(像打拳一样)</p>
<hr>
<h4 id="JSONP-的原理："><a href="#JSONP-的原理：" class="headerlink" title="JSONP 的原理："></a>JSONP 的原理：</h4><p><code>script</code>标签，<code>src</code>属性跨域，jsonp插入<code>script</code>，url参数，get请求</p>
<blockquote>
<p>1.创，2.插，3.返回方法调用，参数是数据，4.前端拿到传来的 方法调用</p>
</blockquote>
<hr>
<h4 id="异步加载JS的方式："><a href="#异步加载JS的方式：" class="headerlink" title="异步加载JS的方式："></a>异步加载JS的方式：</h4><blockquote>
<p>1.<code>defer</code>只能是<code>ie</code>(按顺序执行)</p>
<p>2.async(不会顺序)</p>
<p>3.创建script，插入dom，加载完callBack</p>
</blockquote>
<hr>
<h4 id="常见web安全及防护原理："><a href="#常见web安全及防护原理：" class="headerlink" title="*常见web安全及防护原理："></a>*常见web安全及防护原理：</h4><ul>
<li>XSS：跨站脚本攻击：就是攻击者想尽一切办法将可以<strong>执行的代码注入到网页中。</strong></li>
<li>CSRF：跨站请求伪造，诱骗用户进入第三方网站，向目标网站进行请求，获取注册凭证，绕过后台用户验证</li>
<li>iframe 安全：</li>
<li>第三方依赖包</li>
<li>网络劫持</li>
<li>中间人攻击</li>
</ul>
<hr>
<h4 id="那些操作会造成内存泄漏"><a href="#那些操作会造成内存泄漏" class="headerlink" title="那些操作会造成内存泄漏"></a>那些操作会造成内存泄漏</h4><p>内存泄漏：创建的对象不再拥有或者需要，仍然存在</p>
<p>那些：全局变量(没有var)，(忘)定时器回调函数，闭包，dom引用没清理，计时器(字符串参数)，控制台日志，两个对象彼此引用保留(循环)</p>
<hr>
<h4 id="事件传播的三个阶段是什么：捕获，目标，冒泡"><a href="#事件传播的三个阶段是什么：捕获，目标，冒泡" class="headerlink" title="事件传播的三个阶段是什么：捕获，目标，冒泡"></a>事件传播的三个阶段是什么：捕获，目标，冒泡</h4><hr>
<h4 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h4><p>同步：浏览器请求，页面刷新</p>
<p>异步：浏览器后端请求，页面不刷新</p>
<hr>
<h4 id="前端如何压缩图片："><a href="#前端如何压缩图片：" class="headerlink" title="前端如何压缩图片："></a>前端如何压缩图片：</h4><blockquote>
<p>1.通过input拿到上传的图片文件，</p>
<p>2.转成img</p>
<p>3.canvas压缩绘制 HTMLImageElement</p>
</blockquote>
<p><strong>核心步骤：</strong></p>
<ol>
<li>拿到转化后的img元素后，先取出该元素的宽高度，这个宽高度就是实际图片文件的宽高度。</li>
<li>然后定义一个最大限度的宽高度，如果超过这个限制宽高度，则进行等比例的缩放。</li>
<li>计算好将要压缩的尺寸后，创建canvas实例，设置canvas的宽高度为压缩计算后的尺寸，并将img绘制到上面</li>
</ol>
<hr>
<h4 id="了解-WebSocket和HTTP的区别："><a href="#了解-WebSocket和HTTP的区别：" class="headerlink" title="(了解)WebSocket和HTTP的区别："></a>(了解)WebSocket和HTTP的区别：</h4><ul>
<li>HTTP：长链接是在一定期限内保持链接保持TCP链接不断开，短链接每次请求经历三次挥手👋才能发送信息，必须要客户端主动发起请求，服务器被动返回结果。</li>
<li>WebSocket：解决客户端进行HTTP请求轮训问题，全双工通讯，多路复用。服务器主动权想什么时候发就什么时候发。</li>
</ul>
<hr>
<h4 id="了解-怎么禁止js访问cookie："><a href="#了解-怎么禁止js访问cookie：" class="headerlink" title="(了解)怎么禁止js访问cookie："></a>(了解)怎么禁止js访问cookie：</h4><p>设置HttpOnly，在 cookie 设置 HttpOnly 属性，防止xss攻击</p>
<hr>
<h4 id="了解-对AMD、CMD的理解："><a href="#了解-对AMD、CMD的理解：" class="headerlink" title="(了解)对AMD、CMD的理解："></a>(了解)对AMD、CMD的理解：</h4><p>模块化编程，AMD，异步模块定义(依赖前置)，CMD，通用模块定义(CMD依赖就近)</p>
<hr>
<h4 id="了解-new操作符到底干了什么？"><a href="#了解-new操作符到底干了什么？" class="headerlink" title="(了解)new操作符到底干了什么？"></a>(了解)new操作符到底干了什么？</h4><p>1.创建空对象</p>
<p>2.this = 创建的对象</p>
<p>3.实例原型=构造原型</p>
<p>4.定义实例属性和方法</p>
<p>5.返回this</p>
<hr>
<h4 id="了解-xml和json的区别："><a href="#了解-xml和json的区别：" class="headerlink" title="(了解)xml和json的区别："></a>(了解)xml和json的区别：</h4><blockquote>
<p>XML 指<strong>可扩展标记语言</strong>（e X tensible M arkup L anguage）。XML 被设计用来传输和存储数据。</p>
</blockquote>
<p>体积：json 小</p>
<p>传输速度：json快</p>
<p>结构清晰：json</p>
<p>交互：json 和 js 交互性</p>
<hr>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><hr>
<h4 id="箭头函数注意点："><a href="#箭头函数注意点：" class="headerlink" title="箭头函数注意点："></a>箭头函数注意点：</h4><p>1.this，2.不argument，3.不构造，不new，不yieId，不Generator</p>
<hr>
<h4 id="Set，Map数据结构区别："><a href="#Set，Map数据结构区别：" class="headerlink" title="Set，Map数据结构区别："></a>Set，Map数据结构区别：</h4><blockquote>
<p>Set：重组</p>
<p>1.不重复(去重)，2.类数组，3.遍历，方法</p>
<p>Map：存储</p>
<p>1.键值对类集合，2.遍历，转换</p>
</blockquote>
<hr>
<h4 id="Promise构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#Promise构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="Promise构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</h4><hr>
<h4 id="setTimeout、Promise、Async-x2F-Await-的区别："><a href="#setTimeout、Promise、Async-x2F-Await-的区别：" class="headerlink" title="setTimeout、Promise、Async/Await 的区别："></a>setTimeout、Promise、Async/Await 的区别：</h4><blockquote>
<p>setTimeout的回调，异步宏任务</p>
<p>Promise.then的回调，相应宏任务的微任务队列</p>
<p>异步代码同步化，Async函数异步代码，async返回值是promises，await后执行，微任务队列，让同步代码先执行，跳出整个 async 函数来执行后面js栈的代码。</p>
</blockquote>
<hr>
<h4 id="var为什么代码提升：解决函数互调"><a href="#var为什么代码提升：解决函数互调" class="headerlink" title="var为什么代码提升：解决函数互调"></a><code>var</code>为什么代码提升：解决函数互调</h4><hr>
<h4 id="var、let、const区别："><a href="#var、let、const区别：" class="headerlink" title="var、let、const区别："></a><code>var、let、const</code>区别：</h4><blockquote>
<p>重复声明变量：var ✅、let, const❌</p>
<p>块级作用域：var ❌、let , const✅</p>
<p>window 相映射：var ✅、let,const ❌</p>
<p>声明提升：var ✅、let ,const❌(暂存死区) [定义该变量之前的区域就是暂存性死区]</p>
<p>声明必赋值：const</p>
<p>定义不可变的量：const</p>
</blockquote>
<hr>
<h4 id="get和post的区别：HTTP、请求"><a href="#get和post的区别：HTTP、请求" class="headerlink" title="get和post的区别：HTTP、请求"></a>get和post的区别：HTTP、请求</h4><blockquote>
<p>简快高效：get</p>
<p>安全性：get &lt; post</p>
<p>参数可见：get ✅、post❌</p>
<p>参数类型限制：get ✅、post❌</p>
<p>体积：get &lt; post</p>
<p>缓存：get(304) ✅、post❌</p>
<p>参数保存历史记录：get ✅、post❌</p>
<p>浏览器回退时：get 无害 、post 再请求</p>
<p>浏览器主动catch：get ✅、post(手动)❌</p>
</blockquote>
<p>什么时候用post：</p>
<blockquote>
<p>修改、服务器、数据</p>
<p>1.无法用缓存</p>
<p>2.发送大数据</p>
<p>3.发送未知字符</p>
</blockquote>
<hr>
<h4 id="请谈谈你对ES6的理解："><a href="#请谈谈你对ES6的理解：" class="headerlink" title="请谈谈你对ES6的理解："></a>请谈谈你对ES6的理解：</h4><blockquote>
<p>声明变量：let 和 const（…）</p>
<p>解构赋值：对(典中典三位)，</p>
<p><code>Number</code>数字类型扩展</p>
<blockquote>
<p>数值分隔符</p>
<p>Number.isFinite()</p>
<p>Number.isNaN</p>
</blockquote>
<p><code>Function</code>函数类型扩展</p>
<blockquote>
<p>rest 参数(获取多余参数，就是<code>...</code>，不需要<code>arguments</code>)</p>
<p>箭头函数</p>
</blockquote>
<p><code>Array</code>数组类型扩展</p>
<blockquote>
<p>扩展运算符</p>
<p>Array.from 方法可以将(类数组对象，可遍历对象包括(Set/Map)) 转数组</p>
<p>Array.of() 一组值，转换为数组。</p>
</blockquote>
<p>Set  和  Map(键如何类型)</p>
<p>Proxy：元编程，拦截，过滤修改</p>
<p>Promise（all，race）</p>
<p>class：糖，原型对象清晰，面向对象</p>
<p>ES6模块化：<code>import、export</code></p>
<p>原始数据类型Symbol：对象属性名冲突，标记，防止冲突</p>
<p>for-of：遍历得值</p>
<p>模板字符串</p>
</blockquote>
<hr>
<h4 id="async-和-await："><a href="#async-和-await：" class="headerlink" title="async 和 await："></a>async 和 await：</h4><p>异步代码同步化，async返回值是promises，await后执行，微任务队列，让同步代码先执行，跳出整个 async 函数来执行后面js栈的代码。</p>
<h3 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h3><blockquote>
<p>Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新</p>
<p>Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。</p>
<p>Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种。</p>
<h4 id="Watcher-和-Dep-的关系"><a href="#Watcher-和-Dep-的关系" class="headerlink" title="Watcher 和 Dep 的关系"></a>Watcher 和 Dep 的关系</h4><p>watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。</p>
</blockquote>
<hr>
<h4 id="用Vue实现样式绑定，可以用class或者内联样式："><a href="#用Vue实现样式绑定，可以用class或者内联样式：" class="headerlink" title="用Vue实现样式绑定，可以用class或者内联样式："></a>用Vue实现样式绑定，可以用class或者内联样式：</h4><p>绑定class：<code>[]</code> 或者 <code>{}</code></p>
<p>绑定style：<code>{}</code> 或者 <code>[{}]</code></p>
<hr>
<h4 id="vue-router-中常用的路由模式实现原理"><a href="#vue-router-中常用的路由模式实现原理" class="headerlink" title="vue-router 中常用的路由模式实现原理"></a>vue-router 中常用的路由模式实现原理</h4><p><strong>hash：</strong>location.hash url # 后面，不包含在请求中，不影响后端，不加载页面</p>
<p>添加监听hash改变事件，改变hash，历史记录，更新视图，不请求页面</p>
<p>特点：兼容好，不美观</p>
<p><strong>history:</strong> 利用<code>HTML5</code>中 pushState() 和 replaceState() 方法，应用于历史记录站，back，forward，go基础上，修改历史记录。</p>
<p>特点：美观，怕<strong>刷新</strong>，<strong>f5</strong>，刷新是实实在在地去请求服务器的，出现404，后端进行配置</p>
<p>共同特点：修改历史记录栈，url改变，不刷新页面，前端路由：更新视图不重新请求页面提供基础。</p>
<hr>
<h4 id="vue-router几种导航钩子：5"><a href="#vue-router几种导航钩子：5" class="headerlink" title="vue-router几种导航钩子：5"></a>vue-router几种导航钩子：5</h4><p>1.全局each；2.全局解析resolve；3.全局后置each；4.路由独享enter；5.组件内守卫RouteEnter,Update,Leave</p>
<hr>
<h4 id="前端路由和后端路由的区别："><a href="#前端路由和后端路由的区别：" class="headerlink" title="前端路由和后端路由的区别："></a>前端路由和后端路由的区别：</h4><p><strong>路由：</strong>不同url，不同的页面和内容</p>
<p><strong>前端路由：</strong>重点：页面不刷新；把不用路由对应内容页面给前端做，跳转锚点路由</p>
<p>SPA普及：前后端分离，项目前端路由，页面不刷新</p>
<p>优点：</p>
<p>1.体验好，后台网速无关，每次后台获取，快速展现；</p>
<p>2.输入url访问；</p>
<p>3.前后端分离，方便开发</p>
<p>缺点：前进后退会重新请求，没合理利用缓存；无法前进后退记住之前滚动条位置。</p>
<p><strong>后端路由：</strong>切换url，向后台发请求，拼接html，传给前端。页面刷新，白屏，前后端不分离</p>
<p>优点：减少前端压力，html和数据拼接在服务器</p>
<p>缺点：项目庞大，服务器压力大；url输入不能访问；网速，白屏，用户体验</p>
<hr>
<h4 id="refs-和-el的用法"><a href="#refs-和-el的用法" class="headerlink" title="$refs 和 $el的用法:"></a>$refs 和 $el的用法:</h4><p>1.ref:在普通元素，this.$refs获取到dom元素</p>
<p>2.在子组件上，获取到组件实例，调用组件方法</p>
<p>vm.$el: 获取 vue 实例关联的dom元素， <strong>$el获取组件中的dom元素</strong></p>
<hr>
<h4 id="vue常用的修饰符："><a href="#vue常用的修饰符：" class="headerlink" title="vue常用的修饰符："></a>vue常用的修饰符：</h4><p>.stop：不事件冒泡</p>
<p>.prevent：提交事件不重载</p>
<p>.self：当事件发生在该元素本身而不是子元素的时候会触发，是只有是自己触发的自己才会执行,如果接受到内部的冒泡事件传递信号触发,会忽略掉这个信号</p>
<p>.capture：事件监听</p>
<hr>
<h4 id="vue中v-if与v-show的区别以及使用场景"><a href="#vue中v-if与v-show的区别以及使用场景" class="headerlink" title="vue中v-if与v-show的区别以及使用场景"></a>vue中v-if与v-show的区别以及使用场景</h4><p>v-if：dom节点是否存在，局部编译卸载，惰性，切换消耗；条件很少改变</p>
<p>v-show：display样式，简单的css切换，初始无论什么条件编译，dom元素保留，初始渲染消耗；频繁切换</p>
<hr>
<h4 id="v-if和v-for为什么避免一起用"><a href="#v-if和v-for为什么避免一起用" class="headerlink" title="v-if和v-for为什么避免一起用"></a>v-if和v-for为什么避免一起用</h4><p>优先级：v-for高于v-if，先循环在显示隐藏</p>
<p>过滤列表中的项目：替换为属性，先过滤在循环</p>
<p>避免渲染本该被隐藏的列表：v-if 移动到父级容器上</p>
<hr>
<h4 id="Vuex-为什么要分模块并且加命名空间"><a href="#Vuex-为什么要分模块并且加命名空间" class="headerlink" title="Vuex 为什么要分模块并且加命名空间"></a>Vuex 为什么要分模块并且加命名空间</h4><p>分模块：单一的状态树，所有状态集中到一个对象，store臃肿；store分割模块，每个模块有自己的 state，mutation，action，getter，嵌套子模块。</p>
<p>命名空间：默认：mutation，action，getter注册全局命名空间，多模块对同一mutation，action做响应；模块封装度和复用性，添加命名，注册之后，所有mutation，action，getter，根据注册路径进行调整。</p>
<hr>
<h4 id="使用过-Vue-SSR-吗？说说-SSR"><a href="#使用过-Vue-SSR-吗？说说-SSR" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR"></a>使用过 Vue SSR 吗？说说 SSR</h4><p>ssr 服务器端渲染，服务器标签渲染html，html返回给客户端</p>
<p>优点：seo，首屏加载快</p>
<p>缺点：开发受限，只支持bC和c两钩子，外部扩展库特殊处理，nodejs运行环境，服务器负载</p>
<hr>
<h4 id="vue-中使用了哪些设计模式"><a href="#vue-中使用了哪些设计模式" class="headerlink" title="vue 中使用了哪些设计模式"></a>vue 中使用了哪些设计模式</h4><p>1.工厂(传参创实例)；2.单例(只有一个实例)；3.观察者(响应式数据)；4.发布订阅(vue事件机制)；5.修饰(@)；6.策略(不同场景不同行为)</p>
<hr>
<h4 id="Vue-的性能优化："><a href="#Vue-的性能优化：" class="headerlink" title="Vue 的性能优化："></a>Vue 的性能优化：</h4><ol>
<li>对象层级不过深</li>
<li>不响应式不放data中</li>
<li>if 、show</li>
<li>computed、watch</li>
<li>for要有key，避免if</li>
<li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li>
<li>组件销毁后，内部变量事件销毁，防泄漏</li>
<li>图片懒加载</li>
<li>路由懒加载</li>
<li>第三发插件按需引入</li>
<li>keep-alive 缓存</li>
<li>防抖节流</li>
<li>ssr or 预渲染</li>
</ol>
<hr>
<h4 id="Vue-mixin-的使用场景和原理："><a href="#Vue-mixin-的使用场景和原理：" class="headerlink" title="Vue.mixin 的使用场景和原理："></a>Vue.mixin 的使用场景和原理：</h4><p><strong>使用场景：</strong>不同组件，类似的代码，功能相对独立，抽离；</p>
<p><strong>原理：</strong>类似于<strong>“对象的继承”</strong>，组件初始化，采用策略模式对不同的属性进行合并，同名选项，恰当的方式合并，代码混入在每个组件相对独立；</p>
<p>mixins和vuex区别：值，变量是否受其他组件影响</p>
<p>mixins和组件的区别：合并混入成一个新组件，父子组件是相对独立的</p>
<hr>
<h4 id="keep-alive-使用场景和原理"><a href="#keep-alive-使用场景和原理" class="headerlink" title="keep-alive 使用场景和原理"></a>keep-alive 使用场景和原理</h4><p>内置的组件，组件的缓存，切换组件不会对当前组件进行卸载</p>
<p>两属性：include/exclude、允许组件缓存</p>
<p>两生命周期：activated/deactivated，当前组件是否是活跃状态</p>
<hr>
<h4 id="vue-set-方法原理："><a href="#vue-set-方法原理：" class="headerlink" title="vue.set 方法原理："></a>vue.set 方法原理：</h4><p>不会触发视图层更新的两种情况：</p>
<ol>
<li>响应式对象新增加属性</li>
<li>数组索引修改数组某项值</li>
</ol>
<p>原理：响应式数据，会给对象和数组<code>__ob__</code>属性，表示Observe实例。对象新增加属性，进行响应式跟踪，触发对象<code>__ob__</code>的dep收集到的watcher去更新，当修改数组索引，调用数组本身的splice更新数组。</p>
<hr>
<h4 id="Vue-extend-作用和原理"><a href="#Vue-extend-作用和原理" class="headerlink" title="Vue.extend 作用和原理"></a>Vue.extend 作用和原理</h4><p>官解：使用vue构造器，创建一个子类，参数是包含组件选项的对象</p>
<p><strong>其实</strong>子类构造器，vue 的核心api，<strong>实现思路：</strong>使用原型继承返回vue子类，将传入组件的options和父类options进行合并</p>
<hr>
<h4 id="写过自定义指令吗-原理是什么"><a href="#写过自定义指令吗-原理是什么" class="headerlink" title="写过自定义指令吗 原理是什么"></a>写过自定义指令吗 原理是什么</h4><p>本质上：装饰器，vue对html元素的扩展，增加自定义功能，vue编译dom，会找到指令对象，执行相关方法；</p>
<p>五个生命函数：bind，inserted，update，componentUpdated，unbind</p>
<blockquote>
<ol>
<li><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><p>update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</p>
</li>
<li><p>componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</p>
</li>
<li><p>unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
</ol>
</blockquote>
<p>原理：</p>
<blockquote>
<p>ast语法树，遇到指令给当前的元素添加 <code>directives </code>属性</p>
<p><code>genDirectives</code>生成指令代码</p>
<p>patch前将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</p>
<p>执行对应钩子，调用对应的方法</p>
</blockquote>
<p>©</p>
<p>与组件的区别：组件内部一般有html元素(特定样式、逻辑和功能的实体)；自定义指令一般让已存在的dom元素执行某种操作</p>
<hr>
<h4 id="Vue-模板编译原理："><a href="#Vue-模板编译原理：" class="headerlink" title="Vue 模板编译原理："></a>Vue 模板编译原理：</h4><p>将template转化成 render 函数的过程</p>
<blockquote>
<p>模板字符串转换成 element asts(解析器)</p>
<p>ast进行静态节点标记，虚拟dom的渲染优化(优化器)</p>
<p>使用 element asts 生成 render 函数代码字符串(代码生成器)</p>
</blockquote>
<hr>
<h4 id="生命周期钩子是如何实现的"><a href="#生命周期钩子是如何实现的" class="headerlink" title="生命周期钩子是如何实现的"></a>生命周期钩子是如何实现的</h4><p>核心：利用<strong>发布订阅模式</strong>，把用户传入生命周期钩子订阅好(内用数组存储)，创建组件实例的过程中会执行对应的钩子方法(发布)</p>
<hr>
<h4 id="vue-router如何响应路由参数的变化："><a href="#vue-router如何响应路由参数的变化：" class="headerlink" title="vue-router如何响应路由参数的变化："></a>vue-router如何响应路由参数的变化：</h4><p>路由参数的变化：使用路由参数，<code>/user/foo</code>到<code>/user/bar</code>，组件实例被复用，两个路由渲染同一个组件，复用更高效，组件的钩子函数不调用</p>
<p>检测路由参数变化的方法：</p>
<p>法一：watch 监听；</p>
<p>法二：导航守卫；</p>
<hr>
<h4 id="Vue中data中变量的数据值发生改变，界面没有跟着更新，是什么原因（Vue数据双向绑定失效）"><a href="#Vue中data中变量的数据值发生改变，界面没有跟着更新，是什么原因（Vue数据双向绑定失效）" class="headerlink" title="Vue中data中变量的数据值发生改变，界面没有跟着更新，是什么原因（Vue数据双向绑定失效）"></a>Vue中data中变量的数据值发生改变，界面没有跟着更新，是什么原因（Vue数据双向绑定失效）</h4><p>data 里面定义对象，里面键值没有，getter/setter 函数没有监听到属性值数据变化。</p>
<p>解决方法：Vue.set(obj，key，value)；thsi.$set(obj，key，value)</p>
<hr>
<h4 id="多层父子组件通讯"><a href="#多层父子组件通讯" class="headerlink" title="多层父子组件通讯"></a>多层父子组件通讯</h4><p>嵌套层级比较多的情况下，传递的事件和属性多，代码混乱，利用<code>provide/inject</code></p>
<hr>
<h4 id="父子组件通讯方式有哪些？"><a href="#父子组件通讯方式有哪些？" class="headerlink" title="父子组件通讯方式有哪些？"></a>父子组件通讯方式有哪些？</h4><blockquote>
<p>父→子：自定义属性 ：props</p>
<p>子→父：自定义事件：$emit</p>
<p>兄→兄：EventBus</p>
<p>Vuex</p>
<p>v-model【组件之间也可以进行双向数据绑定，本质就是绑定一个属性和事件】</p>
</blockquote>
<hr>
<h4 id="简述-Vue-的生命周期"><a href="#简述-Vue-的生命周期" class="headerlink" title="简述 Vue 的生命周期"></a>简述 Vue 的生命周期</h4><p>创建前/后，载入前/后，更新前/后，销毁前/后（常用有8）</p>
<ul>
<li><strong>beforeCreated：</strong>data，methods等属性还未被创建,可执行安装插件操作，例如vue.use(vuex)</li>
<li><strong>created：</strong>data，methods中<strong>未操作dom的方法</strong>可以正常使用，DOM结点还未渲染，发送axios请求。</li>
<li><strong>beforeMount：</strong>虚拟DOM已经生成，但还未挂载到真实DOM，无法获取DOM结点。</li>
<li><strong>mounted：</strong>DOM树上已经存在结点，页面渲染成功，我们也可以执行操作DOM操作了，也可以执行发送请求等业务。</li>
<li><strong>beforeupdate：</strong>当响应式数据(data)发生变化时，页面重新渲染数据之前</li>
<li><strong>updated：</strong>页面渲染完过后</li>
<li><strong>beforeDestroy：</strong>组件销毁之前，解除一些全局或自定义事件</li>
<li><strong>destoryed：</strong>生命周期销毁</li>
<li><strong>actived和deactived：</strong>mounted()和destoryed()钩子执行业务的效果</li>
<li><strong>errorCaptured：</strong>当捕获一个来自子孙组件的错误时被调用</li>
</ul>
<p><strong>vue3：</strong></p>
<ul>
<li>**setup()**函数在beforecreate()函数执行之前,已经执行。</li>
<li><strong>beforeUnmount、unmounted</strong></li>
</ul>
<hr>
<h4 id="第一次页面加载会触发哪几个钩子？4"><a href="#第一次页面加载会触发哪几个钩子？4" class="headerlink" title="第一次页面加载会触发哪几个钩子？4"></a>第一次页面加载会触发哪几个钩子？4</h4><hr>
<h4 id="Vue实现数据双向绑定的原理"><a href="#Vue实现数据双向绑定的原理" class="headerlink" title="Vue实现数据双向绑定的原理:"></a>Vue实现数据双向绑定的原理:</h4><p>通过<code>Object.defineProperty()</code>对数据劫持结合发布订阅模式，实现。</p>
<hr>
<h4 id="Vuex刷新页面数据丢失怎么解？（Vuex数据持久化存储）"><a href="#Vuex刷新页面数据丢失怎么解？（Vuex数据持久化存储）" class="headerlink" title="Vuex刷新页面数据丢失怎么解？（Vuex数据持久化存储）"></a>Vuex刷新页面数据丢失怎么解？（Vuex数据持久化存储）</h4><p>Vuex<strong>本质</strong>：一个保存在<strong>内存中的对象</strong></p>
<blockquote>
<p>法一：vuex数据保存到浏览器中(三个缓存)</p>
<p>法二：页面刷新再次请求数据</p>
<p>法三：父页面先请求数据，页面刷新前vuex数据保存到<code>sessionStorage</code></p>
<p>法四：使用插件：vuex-persistedstate</p>
</blockquote>
<hr>
<h4 id="简单讲述-vuex"><a href="#简单讲述-vuex" class="headerlink" title="简单讲述 vuex"></a>简单讲述 vuex</h4><p>状态管理模式，采用集中储存和管理所有组件的状态和数据，方便组件使用。</p>
<p>5属性</p>
<blockquote>
<p>state：存放数据状态(不可直接修改)</p>
<p>getters：类似计算属性，过滤数据</p>
<p>mutations：方法动态修改store中的状态数据</p>
<p>actions：异步操作数据，异步执行 mutations</p>
<p>modules：模块化</p>
</blockquote>
<hr>
<h4 id="Vue-如可自定义一个过滤器"><a href="#Vue-如可自定义一个过滤器" class="headerlink" title="Vue 如可自定义一个过滤器"></a>Vue 如可自定义一个过滤器</h4><p>局部过滤器：filters:{}</p>
<p>全局过滤器：Vue.filter(){}</p>
<hr>
<h4 id="对-keep-alive-的了解"><a href="#对-keep-alive-的了解" class="headerlink" title="对 keep-alive 的了解"></a>对 keep-alive 的了解</h4><p>包裹动态组件，缓存不活动的组件实例，避免组件重新渲染，保存组件状态</p>
<hr>
<h4 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h4><p>函数，复用组件，返回一次新data，每个组件创建私有的数据空间，每个组件实例维护自己的数据。对象，所有组件公用一份 data，造成一变全变</p>
<hr>
<h4 id="Vue-中怎么自定义指令"><a href="#Vue-中怎么自定义指令" class="headerlink" title="Vue 中怎么自定义指令"></a>Vue 中怎么自定义指令</h4><p>全局注册：Vue.directive()</p>
<p>局部注册：directives:{}</p>
<hr>
<h4 id="nextTick-是做什么的"><a href="#nextTick-是做什么的" class="headerlink" title="nextTick 是做什么的"></a>nextTick 是做什么的</h4><p>$nextTick 是 dom 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code> 就可以在回调获取更新后的dom</p>
<hr>
<h4 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a><code>$route</code> 和 <code>$router</code> 的区别</h4><p>$router：为 VueRouter的实例，导航到不同url，使用$router.push方法</p>
<p>$route：当前 router 跳转对象里面 获取参数</p>
<hr>
<h4 id="vue-cli生成的项目文件夹assets和public-static-的区别"><a href="#vue-cli生成的项目文件夹assets和public-static-的区别" class="headerlink" title="vue-cli生成的项目文件夹assets和public(static) 的区别"></a>vue-cli生成的项目文件夹assets和public(static) 的区别</h4><p>2：static；3：public</p>
<p>相同：都是存放静态资源，文件，图片，样式</p>
<p>不同点：</p>
<p>assets：与代码一同打包压缩上传服务器</p>
<p>public(static)：不会进行打包，直接上传</p>
<hr>
<h4 id="DOM渲染在哪个周期中就已经完成"><a href="#DOM渲染在哪个周期中就已经完成" class="headerlink" title="DOM渲染在哪个周期中就已经完成"></a>DOM渲染在哪个周期中就已经完成</h4><p>mounted</p>
<hr>
<h4 id="Virtual-DOM（虚拟DOM）是什么？"><a href="#Virtual-DOM（虚拟DOM）是什么？" class="headerlink" title="Virtual DOM（虚拟DOM）是什么？"></a>Virtual DOM（虚拟DOM）是什么？</h4><p>以js对象为基础的树，对象属性描述节点，对dom抽象，一系列操作映射真实dom</p>
<hr>
<h4 id="为何需要Virtual-DOM"><a href="#为何需要Virtual-DOM" class="headerlink" title="为何需要Virtual DOM"></a>为何需要Virtual DOM</h4><blockquote>
<p>具备平台优势：js为对象，不依赖真实平台环境，有跨平台能力</p>
<p>操作原生dom慢，js效率高：dom 操作放到 js 层</p>
<p>js 和 dom 之间做了一个缓存：</p>
<p>提升渲染性能：大量数据更新，对视图进行合理、高效的更新</p>
</blockquote>
<hr>
<h4 id="Virtual-DOM的diff算法"><a href="#Virtual-DOM的diff算法" class="headerlink" title="Virtual DOM的diff算法"></a>Virtual DOM的diff算法</h4><blockquote>
<p>表示dom树结构，构建真正的dom树，插入文档</p>
<p>状态变更，构造新对象树，新旧比较(diff)，记录差异</p>
<p>差异应用到步骤1的dom树上，视图更新</p>
</blockquote>
<p>通过同层的树节点进行比较，不是对树逐层遍历，时间复杂度只有O(n)</p>
<hr>
<h4 id="如何让CSS只在当前组件中起作用-scoped"><a href="#如何让CSS只在当前组件中起作用-scoped" class="headerlink" title="如何让CSS只在当前组件中起作用: scoped"></a>如何让CSS只在当前组件中起作用: scoped</h4><hr>
<h4 id="修改第三方库的样式"><a href="#修改第三方库的样式" class="headerlink" title="修改第三方库的样式"></a>修改第三方库的样式</h4><blockquote>
<p>/deep/</p>
<p>&gt;&gt;&gt;</p>
<p>::v-deep</p>
</blockquote>
<hr>
<h4 id="讲一讲MVVM"><a href="#讲一讲MVVM" class="headerlink" title="讲一讲MVVM:"></a>讲一讲MVVM:</h4><p><code>Model-View-ViewModel</code></p>
<blockquote>
<p>Model：数据模型</p>
<p>View：UI 组件</p>
<p>ViewModel：桥梁，数据绑定viewModel层自动将数据渲染到页面，视图变化通知vm层更新数据</p>
</blockquote>
<hr>
<h4 id="单向数据流和双向数据流"><a href="#单向数据流和双向数据流" class="headerlink" title="单向数据流和双向数据流"></a>单向数据流和双向数据流</h4><p>单向数据流：一个上传数据和一个下传数据进行单向数据通信，相互独立，单向数据流只能从一个方向来修改</p>
<p>双向数据流：Model中可以修改自己或其他Model的状态，用户的页面操作也可能修改状态，触发一连串的状态</p>
<hr>
<h4 id="说一下MVC的理解"><a href="#说一下MVC的理解" class="headerlink" title="说一下MVC的理解"></a>说一下MVC的理解</h4><p>模型-视图-控制器，m和v代码分离，不同的表现形式，mvc对应html，css，js</p>
<hr>
<h4 id="那你知道Vue3-x响应式数据原理吗？"><a href="#那你知道Vue3-x响应式数据原理吗？" class="headerlink" title="那你知道Vue3.x响应式数据原理吗？"></a>那你知道Vue3.x响应式数据原理吗？</h4><p>Proxy 代替 Object.defineProperty。直接监听对象和数组的变化，达13种拦截方法</p>
<p><strong>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？（拓展）</strong></p>
<p>判断当前Reflect.get的返回值是否为Object，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p>
<p><strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？（拓展）</strong></p>
<p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<hr>
<h4 id="再说一下vue2-x中如何监测数组变化"><a href="#再说一下vue2-x中如何监测数组变化" class="headerlink" title="再说一下vue2.x中如何监测数组变化"></a>再说一下vue2.x中如何监测数组变化</h4><p>函数劫持的方式，重写数组的方法，将data中的数组进行原型链重写，指向自己定义的数组原型方法，调用数组api，可以通知依赖更新，对数组中的引用类型，进行递归遍历监控，实现检测数组的变化</p>
<hr>
<h4 id="Computed和Watch"><a href="#Computed和Watch" class="headerlink" title="Computed和Watch"></a><strong>Computed和Watch</strong></h4><p>Computed：本质有缓存的watcher，依赖属性变化就更新视图，用于计算比较消耗性能的，当模板中的表达式过于复杂，可以放到计算属性中</p>
<p>Watch：没有缓存性，观察作用，监听某些数据执行回调，深度监听，deep：true(性能消耗)；字符串形式监听</p>
<hr>
<h4 id="再说一下虚拟Dom以及key属性的作用"><a href="#再说一下虚拟Dom以及key属性的作用" class="headerlink" title="再说一下虚拟Dom以及key属性的作用"></a>再说一下虚拟Dom以及key属性的作用</h4><p>频繁操作dom元素是很昂贵的，原生js对象描述一个dom节点；</p>
<p>key：尽可能复用dom元素。新旧孩子节点保存映射关系，key是唯一的标识</p>
<hr>
<h4 id="Vue中组件生命周期调用顺序说一下"><a href="#Vue中组件生命周期调用顺序说一下" class="headerlink" title="Vue中组件生命周期调用顺序说一下"></a>Vue中组件生命周期调用顺序说一下</h4><p>调用：先父后子；渲染完成：先子后父</p>
<p>销毁：先父后子；销毁完成：先子后父</p>
<p>更新：先父后子；更新完：先子后父</p>
<hr>
<h4 id="组件设计应遵循什么原则"><a href="#组件设计应遵循什么原则" class="headerlink" title="组件设计应遵循什么原则"></a>组件设计应遵循什么原则</h4><blockquote>
<p>就近管理</p>
<p>高复用性</p>
<p>分层设计（展示层，业务层，持久层，数据层）</p>
<p>灵活扩展，丰富props 和 slot插槽</p>
</blockquote>
<hr>
<h4 id="SSR了解吗"><a href="#SSR了解吗" class="headerlink" title="SSR了解吗"></a>SSR了解吗</h4><p>服务器端渲染。vue，客户端，服务端，返回</p>
<p>更好seo；首屏加载快；只支持两钩子；外部扩展库，nodejs环境；服务器负载</p>
<hr>
<h4 id="在vuejs中实现防止模板渲染时闪烁的方法"><a href="#在vuejs中实现防止模板渲染时闪烁的方法" class="headerlink" title="在vuejs中实现防止模板渲染时闪烁的方法"></a>在vuejs中实现防止模板渲染时闪烁的方法</h4><p>利用：v-cloak，配合dispaly :none</p>
<hr>
<h4 id="你对Vue-js的template编译的理解？"><a href="#你对Vue-js的template编译的理解？" class="headerlink" title="你对Vue.js的template编译的理解？"></a>你对Vue.js的template编译的理解？</h4><p>转化 ast树，得到render函数，返回VNode</p>
<hr>
<h4 id="谈谈Vue-extend和Vue-component"><a href="#谈谈Vue-extend和Vue-component" class="headerlink" title="谈谈Vue.extend和Vue.component"></a>谈谈Vue.extend和Vue.component</h4><p>Vue.extend：返回 扩展实例构造器，预设部分vue实例构造器，服务于Vue.component</p>
<p>Vue.component() 注册全局的组件，判断第二个传进来的是Vue.extend还是普通对象(自动调用Vue.extend)</p>
<hr>
<h4 id="什么是vue的计算属性？"><a href="#什么是vue的计算属性？" class="headerlink" title="什么是vue的计算属性？"></a>什么是vue的计算属性？</h4><p>模板中太多逻辑让模板过重，难于维护。需要对数据进行复杂处理，使用多次。</p>
<p>好处：</p>
<ol>
<li>数据处理结构清晰</li>
<li>依赖于数据更新，结果自动更新</li>
<li>this指向vm实例</li>
<li>模板中写属性名字</li>
<li>getter 获取数据，set 方法修改数据</li>
<li>对比 methods(依赖数据不变也会重新计算)，computed(有缓存)</li>
</ol>
<hr>
<h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><hr>
<h4 id="小程序登录流程"><a href="#小程序登录流程" class="headerlink" title="小程序登录流程"></a>小程序登录流程</h4><ol>
<li>wx.login 获取临时code</li>
<li>将 code 通过<code>wx.request() </code>发送给后端，后端调用微信接口，返回token给前端</li>
<li>前端 token 缓存起来</li>
</ol>
<hr>
<h4 id="微信小程序双向绑定和vue的异同？"><a href="#微信小程序双向绑定和vue的异同？" class="headerlink" title="微信小程序双向绑定和vue的异同？"></a>微信小程序双向绑定和vue的异同？</h4><p>小程序 this.data 属性不能同步到视图，需要调用 this.setData()</p>
<hr>
<h4 id="小程序应用的生命周期"><a href="#小程序应用的生命周期" class="headerlink" title="小程序应用的生命周期"></a>小程序应用的生命周期</h4><blockquote>
<p>onLaunch() 首次触发</p>
<p>onShow() 初始化完成，后台进入前台</p>
<p>onHide() 前台进入后台</p>
<p>onError() 发生脚本错误</p>
</blockquote>
<hr>
<h4 id="小程序页面的生命周期函数？"><a href="#小程序页面的生命周期函数？" class="headerlink" title="小程序页面的生命周期函数？"></a>小程序页面的生命周期函数？</h4><blockquote>
<p>onLoad() 加载</p>
<p>onShow() 显示</p>
<p>onReady() 初次渲染完成</p>
<p>onHide() 隐藏</p>
<p>onUnload() 卸载，跳转到其他页面</p>
</blockquote>
<hr>
<h4 id="应用与页面生命周期触发的顺序"><a href="#应用与页面生命周期触发的顺序" class="headerlink" title="应用与页面生命周期触发的顺序"></a>应用与页面生命周期触发的顺序</h4><p>首次触发 应用生命</p>
<p>应用：onLaunch → onShow → 页面: onLoad → onShow → onReady</p>
<hr>
<h4 id="简述微信小程序原理"><a href="#简述微信小程序原理" class="headerlink" title="简述微信小程序原理"></a>简述微信小程序原理</h4><ol>
<li>本质：单页面应用，所有渲染和事件都在一个页面内进行，可调用原生接口</li>
<li>架构：数据驱动，UI 和数据分离，数据更改实现页面更新</li>
<li>技术：js wxml wxss</li>
<li>功能：webview 和 appService；展示 UI 和 处理业务逻辑、数据、接口</li>
<li>两部分，两进程，通过系统层 JSBridge 实现通信、ui渲染、事件处理</li>
</ol>
<hr>
<h4 id="小程序导入外联样式的方法？-import"><a href="#小程序导入外联样式的方法？-import" class="headerlink" title="小程序导入外联样式的方法？@import"></a>小程序导入外联样式的方法？@import</h4><hr>
<h4 id="哪些方法可以用来提高微信小程序的应用速度"><a href="#哪些方法可以用来提高微信小程序的应用速度" class="headerlink" title="哪些方法可以用来提高微信小程序的应用速度"></a>哪些方法可以用来提高微信小程序的应用速度</h4><ol>
<li>页面加载速度</li>
<li>用户行为预测</li>
<li>data大小</li>
<li>组件化</li>
</ol>
<hr>
<h4 id="webview中的页面怎么跳回小程序中？"><a href="#webview中的页面怎么跳回小程序中？" class="headerlink" title="webview中的页面怎么跳回小程序中？"></a>webview中的页面怎么跳回小程序中？</h4><p>最新版的jweixin-1.3.2.js</p>
<pre class="language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span>miniProgram<span class="token punctuation">.</span>navigateTo</code></pre>

<hr>
<h4 id="如何实现下拉刷新？"><a href="#如何实现下拉刷新？" class="headerlink" title="如何实现下拉刷新？"></a>如何实现下拉刷新？</h4><p>全局配置下：enablePullDownRefresh </p>
<p>Page 定义钩子：onPullDownRefresh  (发请求)</p>
<p>调用wx.stopPullDownRefresh停止下拉刷新</p>
<hr>
<h4 id="小程序的事件"><a href="#小程序的事件" class="headerlink" title="小程序的事件"></a>小程序的事件</h4><p>1.事件父类：冒泡事件/非冒泡事件</p>
<p>2.事件绑定：bind 不阻止事件冒泡，catch 阻止事件冒泡</p>
<p>3.下拉刷新</p>
<hr>
<h4 id="小程序的路由方式"><a href="#小程序的路由方式" class="headerlink" title="小程序的路由方式"></a>小程序的路由方式</h4><p>打开新页面：wx.navigateTo</p>
<p>页面重定向：wx.redirectTo</p>
<p>页面返回：wx.navigateBack</p>
<p>Tab 切换：wx.switchTab</p>
<p>重启动：wx.reLaunch</p>
<hr>
<h4 id="小程序页面间有哪些传递数据的方法"><a href="#小程序页面间有哪些传递数据的方法" class="headerlink" title="小程序页面间有哪些传递数据的方法"></a>小程序页面间有哪些传递数据的方法</h4><ol>
<li>全局变量中传递参数数据，globalData数据，getApp()获取</li>
<li>本地缓存保存数据</li>
<li>跳转、重定向页面，url传递数据，</li>
</ol>
<hr>
<h4 id="用过云开发吗？简述其功能"><a href="#用过云开发吗？简述其功能" class="headerlink" title="用过云开发吗？简述其功能"></a>用过云开发吗？简述其功能</h4><ol>
<li>云函数：微信服务器上的函数，如获取用户信息</li>
<li>数据库：直接操作json数据库，不用服务端</li>
<li>存储：存储文件和图片</li>
</ol>
<hr>
<h3 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h3><hr>
<h4 id="Http和Https的区别？"><a href="#Http和Https的区别？" class="headerlink" title="Http和Https的区别？"></a>Http和Https的区别？</h4><ol>
<li><p>传输信息安全不同</p>
<blockquote>
<p>http：超文本传输协议（明文传输）</p>
<p>https：具有安全性ssl加密传输协议</p>
</blockquote>
</li>
<li><p>连接方式不同</p>
<blockquote>
<p>http：无状态的</p>
<p>https：ssl+Http 加密传输</p>
</blockquote>
</li>
<li><p>端口不同</p>
<blockquote>
<p>http：80端口</p>
<p>https：443端口</p>
</blockquote>
</li>
<li><p>证书申请方式不同</p>
<blockquote>
<p>http：免费</p>
<p>https：交费</p>
</blockquote>
</li>
</ol>
<hr>
<h4 id="HTTP与TCP的关系，介绍一下TCP的三次握手，能否为两次握手，为什么？四次挥手"><a href="#HTTP与TCP的关系，介绍一下TCP的三次握手，能否为两次握手，为什么？四次挥手" class="headerlink" title="HTTP与TCP的关系，介绍一下TCP的三次握手，能否为两次握手，为什么？四次挥手"></a>HTTP与TCP的关系，介绍一下TCP的三次握手，能否为两次握手，为什么？四次挥手</h4><p><code>http</code>基于tcp协议的，客户端发请求，服务器应答。tcp属于<strong>全双工</strong>的</p>
<p>tcp三次握手：</p>
<p>1.客户端向服务端发送TCP的SYN，请求会话</p>
<p>2.服务端发回确认包ACK应答</p>
<p>3.客户端发送ACK确认包</p>
<p>只有两次，服务器无法确定客户端是否收到</p>
<img src="/2022/08/05/interview/1672514-20190430145740399-1189450243.png" alt="img" style="zoom:80%;">

<p>TCP四次挥手：</p>
<ol>
<li>客户端想要释放连接，向服务器发送报文（FIN）</li>
<li>服务器接收到报文，进入半关闭状态，返回ASK报文应答</li>
<li>释放连接，向客户端发送报文（FIN）结束会话</li>
<li>客户端收到报文，ASK应答</li>
</ol>
<p><img src="/2022/08/05/interview/tcp1.jpeg" alt="img"></p>
<hr>
<h4 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h4><ol>
<li>服务器想要和http1.1兼容，为资源实现GET和HEAD方法</li>
<li>GET最常用的方法，用于请求服务器发送资源</li>
<li>HEAD 与 GET 类似，服务器响应中返回首部，不返回实体主体部分</li>
<li>PUT让服务器用请求的主体部分来创建该请求url命名的新文档，如果url已经存在，就用这个主体替代他</li>
<li>POST用来向服务器输入数据，提交表单数据提交到服务器上</li>
<li>TRACE在目标服务器发起环回诊断，最后服务器在TRACE响应主体中携带它收到的原始请求报文，TRACE方法用于诊断，验证请求是否如愿穿过了请求响应链</li>
<li>OPTIONS方法请求服务器告知支持各种功能</li>
<li>DELETE请求服务器删除请求url的指定资源</li>
</ol>
<hr>
<h4 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h4><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="center">Information（信息性状态码）</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加的操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="center">Server Error（服务端错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
<tr>
<td align="left">204</td>
<td align="center"></td>
<td align="center">服务器成功处理，但未返回内容。</td>
</tr>
<tr>
<td align="left">304</td>
<td align="center">Not Modified 未修改。</td>
<td align="center">所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">400</td>
<td align="center">Bad Request</td>
<td align="center">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="center">Not Found</td>
<td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
</tbody></table>
<hr>
<h4 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h4><ol>
<li>防止dom渲染冲突问题</li>
<li>html5中 web worker 可以实现多线程</li>
</ol>
<hr>
<h4 id="同步和异步任务"><a href="#同步和异步任务" class="headerlink" title="同步和异步任务"></a>同步和异步任务</h4><p>同步：在主线程上执行，前任务执行完，才能执行后任务</p>
<p>异步：进任务队列，只有任务队列通知主线程可以进行异步任务了，才执行</p>
<hr>
<h4 id="什么是事件循环（EventLoop）"><a href="#什么是事件循环（EventLoop）" class="headerlink" title="什么是事件循环（EventLoop）"></a>什么是事件循环（EventLoop）</h4><p>node中的事件循环和浏览器的不同</p>
<p>六大阶段：</p>
<p><img src="/2022/08/05/interview/image-20221004130530261.png" alt="image-20221004130530261"></p>
<hr>
<h4 id="什么是内存泄漏，以及常见内存泄漏的原因，和排查的方法"><a href="#什么是内存泄漏，以及常见内存泄漏的原因，和排查的方法" class="headerlink" title="什么是内存泄漏，以及常见内存泄漏的原因，和排查的方法"></a>什么是内存泄漏，以及常见内存泄漏的原因，和排查的方法</h4><p><strong>未能释放已经不再使用的内存的情况</strong></p>
<p>排查方法：</p>
<ol>
<li><p>正常使用可以重现内存泄漏，测试环境可以排除</p>
</li>
<li><p>偶然的内存泄漏，与特殊输入有关，代码日志定位，推荐生产环境打印内存快照</p>
</li>
</ol>
<hr>
<h4 id="简述ajax原理和XmlHttpRequest对象"><a href="#简述ajax原理和XmlHttpRequest对象" class="headerlink" title="简述ajax原理和XmlHttpRequest对象"></a>简述ajax原理和XmlHttpRequest对象</h4><p>ajax原理：通过XmlHttpRequest对象来向服务器发起请求，响应回来的数据，可以在js进行处理，用js来操作dom。</p>
<p>XmlHttpRequest是ajax的核心机制，异步请求，向服务器提出请求和处理响应，不阻塞用户。</p>
<hr>
<h4 id="简述JWT（JSON-Web-Token）鉴权的原理"><a href="#简述JWT（JSON-Web-Token）鉴权的原理" class="headerlink" title="简述JWT（JSON Web Token）鉴权的原理"></a>简述JWT（JSON Web Token）鉴权的原理</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/08/05/interview/jwt.jpg" alt="img"></h4><hr>
<h4 id="（了解）一个tcp接连能发几个http请求？"><a href="#（了解）一个tcp接连能发几个http请求？" class="headerlink" title="（了解）一个tcp接连能发几个http请求？"></a>（了解）一个tcp接连能发几个http请求？</h4><p>http0.1 默认一次tcp，http请求之后就会断开</p>
<p>http1.1请求头配置：keep-alive=true，tcp连接不断开(2小时)，一个tcp一时间支持一个http请求</p>
<p>http2.0 多路复用技术 Multiplexing，tcp并发多个http请求</p>
<hr>
<h4 id="（了解）NodeJs中间件原理"><a href="#（了解）NodeJs中间件原理" class="headerlink" title="（了解）NodeJs中间件原理"></a>（了解）NodeJs中间件原理</h4><p>中间件：就是一个函数（req，res，next下一个中间件）</p>
<p>洋葱圈模型：</p>
<p>最早use的中间件，最外层。处理顺序从左到右，左边接收request，右边返回response。</p>
<p><strong>中间件执行两次</strong>，next之前为一次，next 后一次，控制传递给下游，下游不再有中间件或者next时，恢复上游中间件，上游中间件执行next之后的代码</p>
<hr>
<h4 id="（了解）nodejs的中间件"><a href="#（了解）nodejs的中间件" class="headerlink" title="（了解）nodejs的中间件?"></a>（了解）nodejs的中间件?</h4><p>封装所有http<strong>请求细节处理方法</strong>。一次请求包含很多工作，web应用不希望接触这么多细节处理，中间件简化和隔离基础设施和业务逻辑之间的细节，过滤器，进入具体业务处理之前过滤器处理掉</p>
<hr>
<h4 id="（了解）cookies机制和session机制的区别"><a href="#（了解）cookies机制和session机制的区别" class="headerlink" title="（了解）cookies机制和session机制的区别"></a>（了解）cookies机制和session机制的区别</h4><blockquote>
<p>cookie：保存客户端，减轻服务器压力，不安全</p>
</blockquote>
<blockquote>
<p>session：保存在服务器，相对安全，占用服务器资源</p>
</blockquote>
<hr>
<h4 id="（了解）你知道哪些http头部？"><a href="#（了解）你知道哪些http头部？" class="headerlink" title="（了解）你知道哪些http头部？"></a>（了解）你知道哪些http头部？</h4><blockquote>
<p>HTTP Request Header 常见的请求头：</p>
</blockquote>
<ol>
<li><p>Accept:浏览器能够处理的内容类型</p>
</li>
<li><p>Accept-Charset:浏览器能够显示的字符集</p>
</li>
<li><p>Accept-Encoding：浏览器能够处理的压缩编码</p>
</li>
<li><p>Accept-Language：浏览器当前设置的语言</p>
</li>
<li><p>Connection：浏览器与服务器之间连接的类型</p>
</li>
<li><p>Cookie：当前页面设置的任何Cookie</p>
</li>
<li><p>Host：发出请求的页面所在的域</p>
</li>
<li><p>Referer：发出请求的页面的URL</p>
</li>
<li><p>User-Agent：浏览器的用户代理字符串</p>
</li>
</ol>
<blockquote>
<p>HTTP Responses Header 常见的响应头：</p>
</blockquote>
<ol>
<li><p>Date：表示消息发送的时间，时间的描述格式由rfc822定义</p>
</li>
<li><p>server:服务器名字</p>
</li>
<li><p>Connection：浏览器与服务器之间连接的类型</p>
</li>
<li><p>content-type:表示后面的文档属于什么MIME类型</p>
</li>
<li><p>Cache-Control：控制HTTP缓存</p>
<p>其中Content-type值常用的有以下几种：</p>
</li>
</ol>
<ul>
<li>application/x-www-form-urlencoded：form表单类型 ，浏览器的原生form表单<br>application/json：序列化后的 JSON 字符串，最常用，适合 RESTful 的接口<br>text/xml：是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范<br>multipart/form-data：使用表单上传文件时，必须让 form 的 enctype 等于这个值</li>
</ul>
<hr>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><hr>
<h4 id="（掌握）3-那你再说一说Loader和Plugin的区别？"><a href="#（掌握）3-那你再说一说Loader和Plugin的区别？" class="headerlink" title="（掌握）3. 那你再说一说Loader和Plugin的区别？"></a>（掌握）3. 那你再说一说Loader和Plugin的区别？</h4><p>Loader：本质就是<strong>函数</strong>，对接收<strong>内容进行转换</strong>，返回转换结果，webpack只认识js，loader翻译官，对其他类型资源进行转换的<strong>预处理</strong>工作，(module.rules中进行配置，作为模块的解析规则，类型数组。每一项都是Obj，内部包含test，loader，options等属性)</p>
<p>Plugin：插件，基于事件流框架，<strong>扩展webpack功能</strong>，webpack运行生命周期中广播许多事件，Plugin<strong>监听这些事件</strong>，通过webpack提供的api<strong>改变输出结果</strong>。(在Plugin中单独配置，类型为数组，每一项都是Plugin的实例，参数通过构造函数传入)</p>
<hr>
<h4 id="（掌握）4-Webpack构建流程简单说一下"><a href="#（掌握）4-Webpack构建流程简单说一下" class="headerlink" title="（掌握）4.Webpack构建流程简单说一下"></a>（掌握）4.Webpack构建流程简单说一下</h4><p>串行的过程：</p>
<ol>
<li>初始化参数</li>
<li>开始编译</li>
<li>确定入口</li>
<li>编译模块</li>
<li>完成模块编译</li>
<li>输出资源</li>
<li>输出完成</li>
</ol>
<p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<hr>
<h4 id="（掌握）19、webpack和gulp有什么不同？"><a href="#（掌握）19、webpack和gulp有什么不同？" class="headerlink" title="（掌握）19、webpack和gulp有什么不同？"></a>（掌握）19、webpack和gulp有什么不同？</h4><blockquote>
<p>gulp：重点在于规范前端开发流程，像一个产品的流水线，产品从无到有都要受到流水线的控制，通过task对整个开发过程进行构建</p>
</blockquote>
<blockquote>
<p>webpack：前端资源模块化管理和打包工具，松散的模块按照依赖和规则打包，符合开发环境部署的前端资源。 </p>
</blockquote>
<p>Gulp和Webpack功能实现对比：</p>
<hr>
<h4 id="（掌握）16、webpack打包文件太大怎么办"><a href="#（掌握）16、webpack打包文件太大怎么办" class="headerlink" title="（掌握）16、webpack打包文件太大怎么办?"></a>（掌握）16、webpack打包文件太大怎么办?</h4><ol>
<li>可以从去除不必要的插件</li>
<li>提取第三方库</li>
<li>代码压缩</li>
<li>代码分割</li>
<li>设置缓存</li>
</ol>
<hr>
<h4 id="（了解）5-使用webpack开发时，你用过哪些可以提高效率的插件？"><a href="#（了解）5-使用webpack开发时，你用过哪些可以提高效率的插件？" class="headerlink" title="（了解）5.使用webpack开发时，你用过哪些可以提高效率的插件？"></a>（了解）5.使用webpack开发时，你用过哪些可以提高效率的插件？</h4><ul>
<li><code>webpack-dashboard</code>：可以更友好的展示相关打包信息</li>
<li><code>webpack-merge</code>：提取公共配置，减少重复配置代码</li>
<li><code>speed-measure-webpack-plugin</code>：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li>
<li><code>size-plugin</code>：监控资源体积变化，尽早发现问题</li>
<li><code>HotModuleReplacementPlugin</code>：模块热替换</li>
</ul>
<hr>
<h4 id="source-map是什么？生产环境怎么用？"><a href="#source-map是什么？生产环境怎么用？" class="headerlink" title="source map是什么？生产环境怎么用？"></a>source map是什么？生产环境怎么用？</h4><p><code>source map：</code>是将编译、打包、压缩后的代码映射回源代码的过程。打包后的代码可读性差，源码调试需要<code>source map</code></p>
<p>map文件只要不打开开发者工具，浏览器是不会加载的。</p>
<p>线上环境一般处理方案：</p>
<p><code>sourcemap</code>：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</p>
<hr>
<h4 id="（了解）7-文件监听原理呢？"><a href="#（了解）7-文件监听原理呢？" class="headerlink" title="（了解）7.文件监听原理呢？"></a>（了解）7.文件监听原理呢？</h4><p>发现源码发生<strong>变化</strong>的时，自动重新构建出新的<strong>输出文件</strong></p>
<p>开启监听模式的两种方法：</p>
<ul>
<li><strong>启动</strong>webpack<strong>命令</strong>时候，带上 –watch <strong>参数</strong></li>
<li>在 webpack 配置文件 设置 <strong>watch：true</strong></li>
</ul>
<p>缺点：需要手动刷新浏览器</p>
<p>原理：轮询判断最后的编辑时间是否发生变化，文件发生变化不会立即告诉监听者，先缓存起来，有等待时间在执行</p>
<hr>
<h4 id="（了解）8-说一下-Webpack-的热更新原理吧"><a href="#（了解）8-说一下-Webpack-的热更新原理吧" class="headerlink" title="（了解）8.说一下 Webpack 的热更新原理吧"></a>（了解）8.说一下 Webpack 的热更新原理吧</h4><p>热替换(HMR)。不用刷新浏览器将新模块替换掉旧模块。</p>
<p>HMR核心，客户端从服务器拉去更新后的文件，WDS(路由器)与浏览器之间维护了一个<code>websocket</code>，本地资源发生变化的时候，WDS向浏览器推送更新，客户端进行新旧资源对比，有差异向WDS发起ajax获取更改的内容，借助这些信息继续向WDS发起jsonp请求获取该chunk(块)更新</p>
<hr>
<h4 id="（了解）10-如何对bundle（包）体积进行监控和分析？"><a href="#（了解）10-如何对bundle（包）体积进行监控和分析？" class="headerlink" title="（了解）10. 如何对bundle（包）体积进行监控和分析？"></a>（了解）10. 如何对bundle（包）体积进行监控和分析？</h4><p>vscode 插件 Import Cost 对引入模块大小进行实时监测，利用webpack-bundle-analyzer生成 bundle 模块组成图，显示所占的体积。</p>
<p>bundlesize 工具包进行自动化资源体积监控</p>
<hr>
<h4 id="（了解）12-如何优化-Webpack-的构建速度？"><a href="#（了解）12-如何优化-Webpack-的构建速度？" class="headerlink" title="（了解）12. 如何优化 Webpack 的构建速度？"></a>（了解）12. 如何优化 Webpack 的构建速度？</h4><ol>
<li>使用高版本的 <code>webpack</code> 和 <code>Node.js</code></li>
<li>压缩代码</li>
<li>图片压缩</li>
<li>缩小打包作用域</li>
<li>提取页面公共资源</li>
<li>Dll</li>
<li>充分利用缓存提升二次构建速度</li>
<li>Tree shaking (摇树)</li>
<li>Scope hoisting(作用域提升)</li>
<li>动态<code>polyfill</code></li>
</ol>
<hr>
<h4 id="（了解）13-那代码分割的本质是什么？有什么意义呢？"><a href="#（了解）13-那代码分割的本质是什么？有什么意义呢？" class="headerlink" title="（了解）13. 那代码分割的本质是什么？有什么意义呢？"></a>（了解）13. 那代码分割的本质是什么？有什么意义呢？</h4><p>本质：源代码直接上线 和 打包成唯一脚本 main.bundle.js 两种极端方案之间中间状态</p>
<p>意义：用可接收的服务器性能压力增加来换取更好的用户体验</p>
<p>源代码直接上线：过程可控，http请求多，性能开销大</p>
<p>打包成唯一脚本：服务器压力小，但页面空白期长，用户体验不好</p>
<hr>
<h4 id="（了解）14-是否写过Loader？简单描述一下编写loader的思路？"><a href="#（了解）14-是否写过Loader？简单描述一下编写loader的思路？" class="headerlink" title="（了解）14.是否写过Loader？简单描述一下编写loader的思路？"></a>（了解）14.是否写过Loader？简单描述一下编写loader的思路？</h4><ul>
<li>支持链式调用，遵循<strong>单一职责</strong>，只负责自己要负责的事情</li>
<li>运行在nodejs中，调用nodejs自带的api或安装第三方模块进行调用</li>
<li>webpack给loader 原内容是UTF-8 格式编码字符串</li>
<li>尽可能异步化 Loader</li>
<li>Loader是无状态的</li>
<li>使用 loader-utils 和 schema-utils 提供的实用工具</li>
</ul>
<hr>
<h4 id="（了解）15-是否写过Plugin？简单描述一下编写Plugin的思路？"><a href="#（了解）15-是否写过Plugin？简单描述一下编写Plugin的思路？" class="headerlink" title="（了解）15.是否写过Plugin？简单描述一下编写Plugin的思路？"></a>（了解）15.是否写过Plugin？简单描述一下编写Plugin的思路？</h4><hr>
<p>webpack在运行阶段广播出事件，Plugin可以监听这些事件，特定阶段钩入想要添加的自定义功能。tapable 事件流保证了插件的有序性。</p>
<p>compiler 暴露了和Webpack整个生命周期相关的钩子</p>
<p>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</p>
<p>插件需要在其原型上绑定apply方法，才能访问compiler 实例</p>
<p>传给每给插件的compiler 和compilation对象都是同一个引用，一个插件修改了他们身上的属性，会影响后面的插件。</p>
<p>找出合适的事件点去完成想要的功能</p>
<ul>
<li>emit事件发生</li>
<li>watch-run 当依赖的文件发生变化时会触发</li>
</ul>
<p>异步的事件需要在插件处理完任务时调用回调函数通知webpack进入下一个流程，不然会卡住。</p>
<hr>
<h4 id="（了解）17、什么是长缓存？在webpack中如何做到长缓存优化？"><a href="#（了解）17、什么是长缓存？在webpack中如何做到长缓存优化？" class="headerlink" title="（了解）17、什么是长缓存？在webpack中如何做到长缓存优化？"></a>（了解）17、什么是长缓存？在webpack中如何做到长缓存优化？</h4><p>代码升级更新，浏览器需要下载新的代码，最方便方式就是引入新的文件名称。webpack可以在output中输出文件指定的chunkhash，分离经常更新的代码和框架代码。通过NameModulesPlugin或是HashedModuleldsPlugin使再次打包文件名不变。</p>
<hr>
<h4 id="（了解）18、webpack-dev-server和http服务器-如nginx-有什么区别"><a href="#（了解）18、webpack-dev-server和http服务器-如nginx-有什么区别" class="headerlink" title="（了解）18、webpack-dev-server和http服务器(如nginx)有什么区别?"></a>（了解）18、webpack-dev-server和http服务器(如nginx)有什么区别?</h4><p><code>webpack-dev-server</code>：使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，比传统的http服务对开发更加简单高效</p>
<hr>
<h4 id="（了解）20、前端模块化有哪些"><a href="#（了解）20、前端模块化有哪些" class="headerlink" title="（了解）20、前端模块化有哪些?"></a>（了解）20、前端模块化有哪些?</h4><p>前端模块规范有三种：CommonJs,AMD和CMD。</p>
<p>commonJS：为了JS在后端的表现定制的，不适合前端，用在服务器端。</p>
<p>AMD：依赖前置。定义模块的时候要声明其依赖的模块，提前执行（异步加载：依赖先执行）+延迟执行，用在浏览器环境。</p>
<p>CMD：就近依赖。延迟执行（运行到需加载，根据顺序执行），用到某个模块再去require，用在浏览器环境。</p>
<p>ES 2015在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案</p>
<hr>
<h4 id="（了解）1-有哪些常见的Loader？"><a href="#（了解）1-有哪些常见的Loader？" class="headerlink" title="（了解）1. 有哪些常见的Loader？"></a>（了解）1. 有哪些常见的Loader？</h4><hr>
<h4 id="（了解）2-有哪些常见的Plugin？你用过哪些Plugin？"><a href="#（了解）2-有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="（了解）2.有哪些常见的Plugin？你用过哪些Plugin？"></a>（了解）2.有哪些常见的Plugin？你用过哪些Plugin？</h4><hr>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><h4 id="vue2-x2F-vue3的区别"><a href="#vue2-x2F-vue3的区别" class="headerlink" title="vue2/vue3的区别"></a>vue2/vue3的区别</h4><ol>
<li>vue3的<code>&lt;template&gt;</code>支持多个根标签。</li>
<li>vue3的<code>createApp(顶级组件)</code>创建vue实例。vue2 <code>new Vue({render：h=&gt;h(顶级组件)})</code>     挂载到id为app盒子。</li>
<li>context.emit 与 this.$emit 作用相同</li>
<li>vue3中的属性绑定：默认所有属性都绑定到根元素可用：<code>attrs</code>或者<code>context.attrs</code>获取所有属性，<code>v-bind="$attrs"</code>批量绑定属性，const {} = context.attrs 将属性分开</li>
</ol>
<p><strong>使用场景</strong> 在vue2中我们在父组件绑定click事件，子组件必须内部触发click，而<strong>vue3中在父组件绑定子组件的根元素上也会跟着绑定</strong></p>
<hr>
<h4 id="vue3为什么要使用组合式API"><a href="#vue3为什么要使用组合式API" class="headerlink" title="vue3为什么要使用组合式API"></a>vue3为什么要使用组合式API</h4><ol>
<li>组件有更加良好的代码组织结构；</li>
<li>相同代码逻辑可以在不同组件中进行完整的复用；</li>
</ol>
<hr>
<h4 id="vue3跨组件传值"><a href="#vue3跨组件传值" class="headerlink" title="vue3跨组件传值"></a>vue3跨组件传值</h4><p>props + emit</p>
<p>vuex，pinia</p>
<p>provide 和 inject 的注入</p>
<hr>
<h4 id="vue组合式API有哪些"><a href="#vue组合式API有哪些" class="headerlink" title="vue组合式API有哪些"></a>vue组合式API有哪些</h4><p>ref()，reactive()，watch()，生命周期函数，computed()</p>
<hr>
<h4 id="watchEffect用来代替生命周期里的onMounted和onUpdated"><a href="#watchEffect用来代替生命周期里的onMounted和onUpdated" class="headerlink" title="watchEffect用来代替生命周期里的onMounted和onUpdated"></a>watchEffect用来代替生命周期里的onMounted和onUpdated</h4><p>初始化页面的时候watchEffect里的代码会执行，当watchEffect里的数据有更新的时候同样会执行</p>
<p>注意watchEffect第一次运行是在组件挂载之前，如果需要访问DOM需要将我们的watchEffect放在onMounted里</p>
<hr>
<h4 id="vite和webpack的区别"><a href="#vite和webpack的区别" class="headerlink" title="vite和webpack的区别:"></a>vite和webpack的区别:</h4><p>vite：按需加载，优势在开发环境，启动是不打包，不分析模块依赖，不编译，启动速度快，浏览器动态编译缩短编译的时间。</p>
<p>webpack：全部加载，在启动开发服务器时先打包完再启动开发服务器</p>
<pre class="language-js" data-language="js"><code class="language-js">webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。
而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。

由于现代浏览器本身就支持<span class="token constant">ES</span> Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。
由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。
在<span class="token constant">HMR</span>方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。
当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是<span class="token constant">ES</span> Module，因此在代码中不可以使用CommonJS</code></pre>

<hr>
<h4 id="vite创建vue项目和vue-cli创建项目的区别"><a href="#vite创建vue项目和vue-cli创建项目的区别" class="headerlink" title="vite创建vue项目和vue-cli创建项目的区别:"></a>vite创建vue项目和vue-cli创建项目的区别:</h4><p>vite是web开发构建工具</p>
<p>vue-cli是官方的vue.js项目脚手架</p>
<hr>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><strong>TypeScript</strong></h3><hr>
<h4 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h4><p>1.超集，可选的静态类型，类，面向对象(如：类，接口，继承，泛型等)</p>
<p>2.扩展，大型，兼容</p>
<p>3.TypeScript不直接在浏览器上运行，需要编译器编译成纯js来运行</p>
<hr>
<h4 id="为什么要使用-TypeScript-TypeScript-相对于-JavaScript-的优势是什么？"><a href="#为什么要使用-TypeScript-TypeScript-相对于-JavaScript-的优势是什么？" class="headerlink" title="为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？"></a>为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</h4><p>增加了静态类型，开发人员编写脚本时检测错误，使得代码质量更好，更健壮。</p>
<p>优势：</p>
<blockquote>
<ol>
<li>杜绝手误导致变量名写错；</li>
<li>类型可以一定程度上充当文档；</li>
<li>IDE自动填充，自动联想</li>
</ol>
</blockquote>
<hr>
<h4 id="TypeScript-中-const-和-readonly-的区别？枚举和常量枚举的区别？接口和类型别名的区别？"><a href="#TypeScript-中-const-和-readonly-的区别？枚举和常量枚举的区别？接口和类型别名的区别？" class="headerlink" title="TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？"></a>TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</h4><ul>
<li>const：防止变量的值被修改。readonly：防止变量的属性被修改。</li>
<li>普通枚举：会生成真实存在的对象。常量枚举：不会生成真实存在的对象，而是利用枚举成员的值直接<strong>替换</strong>使用到的地方。</li>
<li>接口和类型别名：两者都可以用来描述对象或函数的类型。类型别名还可以用于其他类型，如基本类型，联合类型，元组</li>
</ul>
<hr>
<h4 id="typescript中内置类型"><a href="#typescript中内置类型" class="headerlink" title="typescript中内置类型"></a>typescript中内置类型</h4><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"jimmy"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bool<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> u<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> n<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> big<span class="token operator">:</span> bigint <span class="token operator">=</span> <span class="token number">100n</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sym<span class="token operator">:</span> <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<hr>
<h4 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h4><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型，可把null和undefined赋值给其他类型。</p>
<hr>
<h4 id="number和bigint"><a href="#number和bigint" class="headerlink" title="number和bigint"></a>number和bigint</h4><p>都表示数字，但是两个类型不相容。</p>
<hr>
<h4 id="any和unknown"><a href="#any和unknown" class="headerlink" title="any和unknown"></a>any和unknown</h4><p>any：任何类型的值可以赋值给<code>any</code>，同时<code>any</code>类型的值也可以赋值给任何型</p>
<p>unknown：如何类型的值都可以赋值给它，但它只能赋值给<code>unknown</code>和<code>any</code></p>
<p>可以使用<code>typeof</code>、类型断言等方式来缩小类型范围。</p>
<hr>
<h4 id="object、Object-和"><a href="#object、Object-和" class="headerlink" title="object、Object 和 {}"></a>object、Object 和 {}</h4><ul>
<li><strong>object：</strong>代表所有非原始的数据类型，不能把<code>number</code>和<code>string</code>和<code>boolean</code>和<code>symbol</code>赋值给object，严格模式下<code>null</code>和<code>undefined</code>也不行</li>
<li><strong>Object ：</strong>包含原始类型。</li>
<li>{}：原始类型和非原始类型的集合，严格模式下，null 和 undefined也不能赋值给<code>{}</code></li>
</ul>
<p>结论：{}、<code>Object</code>是比<code>object</code>更广泛的类型，{} 和大 Object 可以互相代替，用来表示原始类型（<strong>null、undefined 除外</strong>）和非原始数据类型；而object 表示非原始类型。</p>
<hr>
<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>表示没有任何类型：和其他类型是平等的。<strong>不能直接赋值。</strong></p>
<p>只能为它赋予<code>null</code>和<code>undefined</code>。一般只有<strong>函数没有返回值</strong>时去声明。</p>
<p><strong>注意：</strong>方法没有返回值将得到<code>undefined</code>，但是我们要定义<code>void</code>类型，不是<code>undefined</code>类型。</p>
<hr>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p><strong>函数重载或方法重载是使用相同名称和不同参数数量或者类型创建多个方法的一种能力。</strong></p>
<p>同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 声明：</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">arg1</span><span class="token operator">:</span> string<span class="token punctuation">,</span> arg2<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> string
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">arg1</span><span class="token operator">:</span> number<span class="token punctuation">,</span> arg2<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number
<span class="token comment">// 实现：</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">arg1</span><span class="token operator">:</span> string <span class="token operator">|</span> number<span class="token punctuation">,</span> arg2<span class="token operator">:</span> string <span class="token operator">|</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> arg1 <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> arg2 <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> arg1 <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> arg2 <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<hr>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul>
<li><p>对字符串数组类型定义两种方式：</p>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr2<span class="token operator">:</span><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>联合类型数组：</p>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">let</span> arr3<span class="token operator">:</span><span class="token punctuation">(</span>num <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>指定对象成员的数组：</p>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Arrobj</span><span class="token punctuation">{</span>
    name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span><span class="token builtin">number</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> arr4<span class="token operator">:</span>Arrobj<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">"jimmy"</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre></li>
</ul>
<hr>
<h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><p><code>never</code>类型表示的是那些永不存在的值的类型；</p>
<p>值会永不存在的两种情况：</p>
<ol>
<li>函数执行<strong>抛出异常</strong>：函数永远不存在返回值。</li>
<li>函数中执行<strong>无限循环</strong>的代码(死循环)，</li>
</ol>
<hr>
<h4 id="接口和类型别名type有什么区别"><a href="#接口和类型别名type有什么区别" class="headerlink" title="接口和类型别名type有什么区别"></a>接口和类型别名type有什么区别</h4><ul>
<li><strong>接口：</strong>可以继承，还可以重复声明，当有多个命名一样的接口，被定义的类型会发生<strong>合并</strong>，但是不支持（联合/交叉类型/元组）</li>
<li><strong>类型别名：</strong>不可以继承，也不可以重复定义（会覆盖掉），支持使用联合类型和交叉类型。</li>
</ul>
<hr>
<h4 id="类型收窄"><a href="#类型收窄" class="headerlink" title="类型收窄"></a>类型收窄</h4><ul>
<li>从<strong>宽类型</strong>转换成<strong>窄类型</strong>的过程，常用于处理<strong>联合类型变量</strong>的场景。</li>
<li>收窄类型：<ul>
<li>类型断言</li>
<li>类型守卫</li>
<li>双重类型</li>
</ul>
</li>
</ul>
<hr>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul>
<li><p>明确告诉ts值的详细类型</p>
<pre class="language-ts" data-language="ts"><code class="language-ts">值 <span class="token keyword">as</span> 类型		or		<span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span>值</code></pre>
</li>
<li><p><code>tsx</code>语法：<code>&lt;&gt;</code>容易跟泛型语法起冲突，建议统一使用<code>值 as 类型</code></p>
</li>
<li><p>当<code>ts</code>不确定一个联合类型的变量是那个类型，<strong>只能访问此联合类型的所有类型中共有的属性或方法。</strong></p>
</li>
<li><p>欺骗ts，无法避免运行时的错误。</p>
</li>
<li><p>尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p>
</li>
</ul>
<hr>
<h4 id="类型保护的方式有哪些"><a href="#类型保护的方式有哪些" class="headerlink" title="类型保护的方式有哪些"></a>类型保护的方式有哪些</h4><ul>
<li>联合类型<ul>
<li>联合类型结合<code>if/else</code>判断语句，保护类型，指定类型才能调用指定的方法</li>
</ul>
</li>
<li>in 语法<ul>
<li>当类型区别于其他方法有特定的属性是可以用in语法来保护类型启动对应的类型方法和属性等。</li>
</ul>
</li>
<li>typeof<ul>
<li>某数据类型是指定的某原始类型，可以用<code>typeof</code>结合<code>===</code>l运算符进行类型保护</li>
</ul>
</li>
<li>instanceof语法<ul>
<li>判断某对象类型数据是否来自于对应的构造函数(instanceof用于检查构造函数的prototype属性是否存在于某实例里)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="元组越界问题"><a href="#元组越界问题" class="headerlink" title="元组越界问题"></a>元组越界问题</h4><pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">let</span> aaa<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 添加时不会报错</span>
aaa<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印整个元祖不会报错</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aaa<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['aaa',5,6];</span>
<span class="token comment">// 打印添加的元素时会报错</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aaa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span></code></pre>

<hr>
<h4 id="常量枚举与普通枚举的区别"><a href="#常量枚举与普通枚举的区别" class="headerlink" title="常量枚举与普通枚举的区别"></a>常量枚举与普通枚举的区别</h4><ul>
<li>常量枚举会在编译阶段被删除</li>
<li>枚举成员只能是常量成员</li>
<li>常量枚举不能包含计算成员，如果包含了计算成员，会在编译阶段就报错</li>
</ul>
<hr>
<h4 id="什么是函数类型接口"><a href="#什么是函数类型接口" class="headerlink" title="什么是函数类型接口"></a>什么是函数类型接口</h4><ul>
<li><p><strong>对 方法 传入的参数和返回值进行约束</strong></p>
<p><strong>注意区别：</strong></p>
<ul>
<li><p>普通接口</p>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">discount1</span><span class="token punctuation">{</span>
  <span class="token function-variable function">getNum</span> <span class="token operator">:</span> <span class="token punctuation">(</span>price<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数类型接口</p>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">discount2</span><span class="token punctuation">{</span>
  <span class="token comment">// 注意:</span>
  <span class="token comment">// “:” 前面的是函数的签名，用来约束函数的参数</span>
  <span class="token comment">// ":" 后面的用来约束函数的返回值</span>
  <span class="token punctuation">(</span>price<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> cost<span class="token operator">:</span><span class="token function-variable function">discount2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>price<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">.8</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>类型别名</p>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Add</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span>
<span class="token keyword">let</span> add<span class="token operator">:</span> <span class="token function-variable function">Add</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b</code></pre></li>
</ul>
</li>
</ul>
<hr>
<h4 id="继承-vs-多态"><a href="#继承-vs-多态" class="headerlink" title="继承 vs 多态"></a>继承 vs 多态</h4><ul>
<li><strong>继承：</strong>子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li><strong>多态：</strong>由继承产生了相关不同的类，对同一个方法可以有不同的响应</li>
</ul>
<pre class="language-ts" data-language="ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">speak</span><span class="token punctuation">(</span>word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'Animal: '</span> <span class="token operator">+</span> word<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">speak</span><span class="token punctuation">(</span>word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'Cat:'</span> <span class="token operator">+</span> word<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">speak</span><span class="token punctuation">(</span>word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'Dog:'</span> <span class="token operator">+</span> word<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<hr>
<h4 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h4><ul>
<li>泛型是指在定义<strong>函数、接口或类</strong>的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。</li>
<li>可以把泛型理解为代表类型的<strong>参数</strong></li>
</ul>
<hr>
<h4 id="非空断言符的使用"><a href="#非空断言符的使用" class="headerlink" title="非空断言符的使用"></a>非空断言符的使用</h4><p>**!**：非空断言操作符–&gt; 这样写只是为了骗过编译器，防止编译的时候报错，打包后的代码可能还是会报错</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> <span class="token literal-property property">root2</span><span class="token operator">:</span> <span class="token punctuation">(</span>HTMLElement <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
root2<span class="token operator">!</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span></code></pre>

<hr>
<h2 id="TypeScript-中-等符号的含义？"><a href="#TypeScript-中-等符号的含义？" class="headerlink" title="**TypeScript 中 ?.  ??  !  !.  _  ** 等符号的含义？"></a>**TypeScript 中 ?.  ??  !  !.  _  ** 等符号的含义？</h2><ul>
<li><strong>?.可选链：</strong>遇到null 和 undefined 可以立即停止表达式的运行。</li>
<li><strong>?? 空值合并运算符：</strong>当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。</li>
<li><strong>! 非空断言运算符：</strong>x! 将从 x 值域中排除 null 和 undefined 。</li>
<li>**!.**在变量名后添加，可以断言排除undefined和null类型</li>
<li><strong>_ 数字分割符：</strong>分隔符不会改变数值字面量的值，使人更容易读懂数字  <code>1_101_324</code></li>
<li>** :求幂</li>
</ul>
<hr>
<h4 id="declare，declare-global是什么？"><a href="#declare，declare-global是什么？" class="headerlink" title="declare，declare global是什么？"></a>declare，declare global是什么？</h4><blockquote>
<p>declare 是用来定义全局变量、全局函数、全局命名空间、js modules、class等</p>
<p>declare global 为全局对象 <code>window</code> 增加新的属性</p>
</blockquote>
<pre class="language-js" data-language="js"><code class="language-js">declare global <span class="token punctuation">{</span> 
   <span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span> 
        <span class="token literal-property property">csrf</span><span class="token operator">:</span> string<span class="token punctuation">;</span> 
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<hr>
<h4 id="对-TypeScript-类中成员的-public、private、protected、readonly-修饰符的理解？"><a href="#对-TypeScript-类中成员的-public、private、protected、readonly-修饰符的理解？" class="headerlink" title="对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？"></a>对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？</h4><ul>
<li><strong>public：</strong>成员都默认为<code>public</code>，被此限定符修饰的成员是可以被外部访问；</li>
<li><strong>private：</strong>被此限定符修饰的成员是只可以被类的内部访问；</li>
<li><strong>protected：</strong>被此限定符修饰的成员是只可以被类的内部以及类的子类访问;</li>
<li><strong>readonly ：</strong>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</li>
</ul>
<hr>
<h4 id="keyof-和-typeof-关键字的作用？"><a href="#keyof-和-typeof-关键字的作用？" class="headerlink" title="keyof 和 typeof 关键字的作用？"></a>keyof 和 typeof 关键字的作用？</h4><ul>
<li><strong>keyof ：索引类型查询操作符</strong>    获取索引类型的属性名，构成联合类型。</li>
<li><strong>typeof ：</strong>取一个变量或对象的类型。</li>
</ul>
<hr>
<h4 id="简述工具类型-Exclude、Omit、Merge、Intersection、Overwrite的作用。"><a href="#简述工具类型-Exclude、Omit、Merge、Intersection、Overwrite的作用。" class="headerlink" title="简述工具类型 Exclude、Omit、Merge、Intersection、Overwrite的作用。"></a>简述工具类型 <code>Exclude</code>、<code>Omit</code>、<code>Merge</code>、<code>Intersection</code>、<code>Overwrite</code>的作用。</h4><ul>
<li><strong>Exclude&lt;T,U&gt;：</strong>从 <code>T</code> 中排除出可分配给 <code>U</code>的元素。</li>
<li><strong>Omit&lt;T, K&gt;：</strong> 的作用是忽略<code>T</code>中的某些属性。</li>
<li><strong>Merge&lt;O1, O2&gt;：</strong>是将两个对象的属性合并。</li>
<li><strong>Compute&lt;A &amp; B&gt;：</strong>是将交叉类型合并</li>
<li><strong>Intersection&lt;T, U&gt;：</strong>的作用是取<code>T</code>的属性,此属性同样也存在与<code>U</code>。</li>
<li><strong>Overwrite&lt;T, U&gt;：</strong>是用<code>U</code>的属性覆盖<code>T</code>的相同属性。</li>
</ul>
<hr>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><hr>
<h4 id="（掌握）git-reset、git-revert和git-checkout有什么区别？"><a href="#（掌握）git-reset、git-revert和git-checkout有什么区别？" class="headerlink" title="（掌握）git reset、git revert和git checkout有什么区别？"></a>（掌握）git reset、git revert和git checkout有什么区别？</h4><p>提交层面</p>
<blockquote>
<p><strong>reset</strong> 不会改变现在的提交历史。用在私有分支上。<code>git reset HEAD</code>撤销没提交的更改。</p>
<p>revert 用在公共分支上。撤销已提交的更改。</p>
</blockquote>
<hr>
<h4 id="（掌握）一、git-pull-和-git-fetch-之间有什么区别？"><a href="#（掌握）一、git-pull-和-git-fetch-之间有什么区别？" class="headerlink" title="（掌握）一、git pull 和 git fetch 之间有什么区别？"></a>（掌握）一、<code>git pull</code> 和 <code>git fetch</code> 之间有什么区别？</h4><p>git pull：从远程获取新版本并merge到本地</p>
<p>git fetch：从远程获取新版本到本地，不会自动merge</p>
<p>简单来说：git pull = git fetch + git  merge</p>
<hr>
<h4 id="（掌握）二、如何在-Git-恢复先前的提交？"><a href="#（掌握）二、如何在-Git-恢复先前的提交？" class="headerlink" title="（掌握）二、如何在 Git 恢复先前的提交？"></a>（掌握）二、如何在 Git 恢复先前的提交？</h4><p>撤销提交但保留更改：</p>
<pre class="language-js" data-language="js"><code class="language-js">git reset 当前文件
git status 检测更改</code></pre>

<p>修改提交中的更改：<strong>git reset –hard  当前文件名</strong>（如果使用 –hard，文件将提交时间的状态）</p>
<p>撤销提交但保留文件和索引：git reset –soft  文件名</p>
<hr>
<h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><h4 id="简述VirtualDOM及其工作原理"><a href="#简述VirtualDOM及其工作原理" class="headerlink" title="简述VirtualDOM及其工作原理"></a>简述VirtualDOM及其工作原理</h4><p>虚拟DOM 是轻量级的js对象，React的渲染函数从组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化由用户或者系统完成的各个动作引起的。</p>
<p><strong>三个步骤：</strong></p>
<ol>
<li>每当底层数据发生变化的时候，整个UI在虚拟dom中重新渲染。</li>
<li>比较两个虚拟DOM之间的差异</li>
<li>计算完成，将只用实际更改的内容更新 real DOM。</li>
</ol>
<hr>
<h4 id="为什么浏览器无法读取JSX？"><a href="#为什么浏览器无法读取JSX？" class="headerlink" title="为什么浏览器无法读取JSX？"></a>为什么浏览器无法读取JSX？</h4><p>浏览器只能处理 JS 对象。不能读取常规的 JS 对象中的  JSX。可以使用 Babel 将 JSX 转换为 JS 对象传给浏览器。</p>
<hr>
<h4 id="解释-React-中-render-的目的。"><a href="#解释-React-中-render-的目的。" class="headerlink" title="解释 React 中 render() 的目的。"></a>解释 React 中 render() 的目的。</h4><p>每个react组件必须有一个render函数，它返回的是一个react元素，是原生DOM组件的表示。</p>
<p>如果渲染多个HTML元素，必须将他们组合放在一个封闭的标立里面。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</p>
<hr>
<h4 id="详细解释-React-组件的生命周期方法"><a href="#详细解释-React-组件的生命周期方法" class="headerlink" title="详细解释 React 组件的生命周期方法"></a>详细解释 React 组件的生命周期方法</h4><ul>
<li><code>componentWillMount()</code> - 在渲染之前执行，客户端和服务器端都会执行。</li>
<li><code>componentDidMount()</code> - 仅在第一次渲染后在客户端执行。</li>
<li><code>componentWillReceiveProps() </code>当组件接受到新的props时调用父组件更新状态时子组件的重新渲染。</li>
<li><code>shouldComponentUpdate() </code>根据特定的条件返回true或者false。如果你希望跟新组件请返回true否者返回false，默认为false。</li>
<li><code>componentWillUpdate()</code> - 在 DOM 中进行渲染之前调用。</li>
<li><code>componentDidUpdate()</code> - 在渲染发生后立即调用。</li>
<li><code>componentWillUnmount()</code> - DOM 卸载组件后调用，用于清理内存空间。</li>
</ul>
<hr>
<h4 id="你对-React-的-refs-有什么了解？"><a href="#你对-React-的-refs-有什么了解？" class="headerlink" title="你对 React 的 refs 有什么了解？"></a>你对 React 的 refs 有什么了解？</h4><p>refs是react中引用的简写。它是一个有助于存储对特定的react元素或者组件的引用的属性，它将由组件渲染配置函数返回。<strong>用于</strong>对render()返回的特定元素或组件的引用。当需要进行DOM测量或向组件添加方法时，派上用场。</p>
<hr>
<h4 id="react的工作原理"><a href="#react的工作原理" class="headerlink" title="react的工作原理"></a>react的工作原理</h4><p>React 会创建一个虚拟 DOM。当一个组件中的状态改变时，react首先会通过 <code>diffing</code>算法来标记虚拟DOM中的改变，第二步是进行调节，会用<code>diff</code>结果来更新DOM。</p>
<hr>
<h4 id="什么是高阶组件（HOC）？它可以做什么？"><a href="#什么是高阶组件（HOC）？它可以做什么？" class="headerlink" title="什么是高阶组件（HOC）？它可以做什么？"></a>什么是高阶组件（HOC）？它可以做什么？</h4><p>高阶组件是重用组件逻辑的高级方法，是一种源于React的组件模式。HOC是自定义组件，在它之内包含另一个组件，它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。可以认为HOC是<code>纯</code>组件。</p>
<p><strong>HOC可用于许多任务，例如：</strong></p>
<ul>
<li>代码重用，逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>状态抽象和控制</li>
<li>Props 控制</li>
</ul>
<hr>
<h4 id="Redux遵循的三个原则是什么？"><a href="#Redux遵循的三个原则是什么？" class="headerlink" title="Redux遵循的三个原则是什么？"></a>Redux遵循的三个原则是什么？</h4><ol>
<li><strong>单一事件来源：</strong>整个应用状态存储在单一的store的对象/状态树里。单一状态树可以更容易地跟踪随着时间的变化，并调试或检查应用程序。</li>
<li><strong>状态是只读的：</strong>改变状态的唯一方法是去<strong>触发一个动作</strong>。动作是描述变化的普通JS对象。就像<code>state</code>是数据的最小表示一样，该操作是对数据更改的最小表示。</li>
<li><strong>使用纯函数进行更改：</strong>为了指定状态树如何通过操作进行转换，需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</li>
</ol>
<hr>
<h4 id="你对“单一事实来源”有什么理解？"><a href="#你对“单一事实来源”有什么理解？" class="headerlink" title="你对“单一事实来源”有什么理解？"></a>你对“单一事实来源”有什么理解？</h4><p><code>Redux</code>使用<code>Store</code>将程序整个状态存储在同一个地方。所有组件的状态存储在<code>Store</code>中，<code>Store</code>本身接受更新。单一状态树可以更容易地跟踪随时间变化，并调试或检查程序。</p>
<hr>
<h4 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h4><p>因为<code>this.props</code>和<code>this.state</code>的更新可能是异步的，不能依赖他们的值去计算下一个<code>state</code>。</p>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><hr>
<p><img src="/2022/08/05/interview/v2-d64071b050db7a8698eceb03acfccc53_720w.jpg" alt="img"></p>
<hr>
<h4 id="Tree-Shaking-摇树"><a href="#Tree-Shaking-摇树" class="headerlink" title="Tree Shaking(摇树)"></a>Tree Shaking(摇树)</h4><p>项目中引入其他模块时，自动将我们用不到的代码，或者永远不会执行的代码摇掉</p>
<hr>
<h4 id="强缓存、协商缓存"><a href="#强缓存、协商缓存" class="headerlink" title="强缓存、协商缓存"></a>强缓存、协商缓存</h4><p>强缓存：不会向服务器发送请求，直接从本地获取数据，200</p>
<blockquote>
<p>服务器响应  Response Headers  中添加一下:</p>
</blockquote>
<ul>
<li><strong>expires：</strong>服务器给定一个过期时间戳，客户端时间对比过期时间。（客户端时间可能会不准）</li>
<li><strong>cache-control：</strong>服务器给时间长度，单位秒，在有效时间内使用缓存，不依赖客户端时间。（优先级可能会更高）</li>
</ul>
<p>协商缓存：向服务器请求，是否可以使用缓存，304</p>
<hr>
<h4 id="为什么封装请求"><a href="#为什么封装请求" class="headerlink" title="为什么封装请求"></a>为什么封装请求</h4><ol>
<li>多个链接都要带请求头，请求头写在那里？</li>
<li>不利于接口的管理和维护</li>
<li>回调地狱</li>
</ol>
<hr>
<h4 id="axios有什么特性？（不得不说面试被问到几次）"><a href="#axios有什么特性？（不得不说面试被问到几次）" class="headerlink" title="axios有什么特性？（不得不说面试被问到几次）"></a>axios有什么特性？（不得不说面试被问到几次）</h4><ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<hr>
<h4 id="JS常用数据结构"><a href="#JS常用数据结构" class="headerlink" title="JS常用数据结构"></a>JS常用数据结构</h4><ul>
<li>数组（Array）</li>
<li>栈(stack)</li>
<li>队列（Queue）</li>
<li>链表（Linked List）</li>
<li>散列表(Hash)</li>
<li>树（Tree）</li>
<li>堆（Heap）</li>
<li>图（Graph）</li>
</ul>
<hr>
<h4 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h4><ul>
<li>在<strong>正向代理</strong>的过程中，代理服务器代替客户端向目标服务器发送请求，目标服务器不知道谁是真正的客户端，不知道访问自己的是一个代理服务器还是客户端。服务器只负责将响应包发送给请求方。</li>
<li>在<strong>反向代理</strong>的过程中，客户端不知道自己<strong>请求</strong>的是代理服务器还是业务服务器。</li>
</ul>
<hr>
<h4 id="怎么实现同一用户，异地登录时候被踢下来"><a href="#怎么实现同一用户，异地登录时候被踢下来" class="headerlink" title="怎么实现同一用户，异地登录时候被踢下来"></a>怎么实现同一用户，异地登录时候被踢下来</h4><p>进行获取新的token，删除旧的token</p>
<hr>
<h4 id="关于前端实现token无感刷新-refresh-token"><a href="#关于前端实现token无感刷新-refresh-token" class="headerlink" title="关于前端实现token无感刷新(refresh_token)"></a>关于前端实现token无感刷新(refresh_token)</h4><p>当token过期的时候，刷新token,前端需要做到无感刷新token,即刷token时要做到用户无感知，避免频繁登录。 实现思路</p>
<p>在响应拦截器中拦截，先发起请求，接口返回<code>token</code>过期后，调用刷新token接口，再重新请求。</p>
<hr>
<h4 id="什么是单点登录-SSO-？单点登录-SSO-到底什么意思？【附逻辑Demo实例】"><a href="#什么是单点登录-SSO-？单点登录-SSO-到底什么意思？【附逻辑Demo实例】" class="headerlink" title="什么是单点登录(SSO)？单点登录(SSO)到底什么意思？【附逻辑Demo实例】"></a>什么是单点登录(SSO)？单点登录(SSO)到底什么意思？【附逻辑Demo实例】</h4><p>单点登录要解决的就是，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p><img src="/2022/08/05/interview/image-20221004130358035.png" alt="image-20221004130358035"></p>
<hr>
<h4 id="for与forEach，哪个更快？为什么？"><a href="#for与forEach，哪个更快？为什么？" class="headerlink" title="for与forEach，哪个更快？为什么？"></a>for与forEach，哪个更快？为什么？</h4><p><strong>for快</strong></p>
<ul>
<li>for 不会创建函数</li>
<li>forEach 每次都要创建一个函数来调用</li>
<li>函数现需要独立的作用域,会有额外开销</li>
</ul>
<hr>
<h4 id="forEach的原理？可以用break、return、continue吗？怎么写？"><a href="#forEach的原理？可以用break、return、continue吗？怎么写？" class="headerlink" title="forEach的原理？可以用break、return、continue吗？怎么写？"></a>forEach的原理？可以用break、return、continue吗？怎么写？</h4><p>forEach用于遍历数组的方法，底层还是for循环，将遍历到的元素传递给回调函数,遍历的数组不能是空的要有值。</p>
<ul>
<li>map，forEach不能使用break跳出整个循环，不能使用continue跳出本次循环。使用retrun相当于for中的continue的作用，结束本次循环的回调函数</li>
</ul>
<p>forEach() 跳出循环的方法</p>
<ul>
<li>使用 for 循环代替 <code>forEach</code>（这个很简单这里就不写例子了）</li>
<li>使用<code>try···catch</code>捕获异常实现</li>
</ul>
<p>ES6 推出了一个 <code>for...of</code> 的语法，内部的实现原理是通过实现 可迭代（iterable） 去实现的，因此内部可以使用 continue, break，return，yield</p>
<hr>
<h4 id="webpack你用了那些加载器？"><a href="#webpack你用了那些加载器？" class="headerlink" title="webpack你用了那些加载器？"></a>webpack你用了那些加载器？</h4><ul>
<li><p>css-loader 处理css中路径引用等问题</p>
<p>（用于在js中加载css，解释<code>@import</code>和<code>url()</code>）</p>
</li>
<li><p>style-loader 动态把样式写入css</p>
<p>（加载的css作为style标签内容插入到html中,以<code>&lt;style&gt;&lt;/style&gt;</code>形式在html页面中插入css代码）</p>
</li>
<li><p>postcss-loader</p>
<p><code>postcss-loader</code>：为了浏览器的兼容性，有时候我们必须加上<code>-webkitm</code>, <code>-ms</code>, <code>-moz</code>等前缀。目的就是让页面可以在每个浏览器上正常运行。postcss是一个CSS的处理平台可以帮CSS实现更多的功能。</p>
</li>
<li><p>less-style</p>
<p>添加对webpack的LESS支持。当遇到less文件时，先交给less-loader处理，然后交给css-loader，最后交由style-loader处理，然后执行webpack打包</p>
</li>
<li><p>ile-loader 分发文件到output目录并返回相对路径</p>
</li>
<li><p>url-loader 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</p>
</li>
<li><p>html-minify-loader 压缩HTML</p>
</li>
<li><p>babel-loader 用babel来转换ES6文件到ES5</p>
</li>
</ul>
<hr>
<h4 id="TCP与UDP的区别？"><a href="#TCP与UDP的区别？" class="headerlink" title="TCP与UDP的区别？"></a>TCP与UDP的区别？</h4><blockquote>
<p>CP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p>
</blockquote>
<p><strong>TCP</strong> ：传输控制协议(Transmission Control Protocol)</p>
<p><strong>UDP</strong> ：用户数据报协议(User Datagram Protocol)</p>
<p><img src="/2022/08/05/interview/2580638-20211024203122288-1643698355.png" alt="img"></p>
<hr>
<h4 id="http状态码代表的意思？100？500？301？302？"><a href="#http状态码代表的意思？100？500？301？302？" class="headerlink" title="http状态码代表的意思？100？500？301？302？"></a>http状态码代表的意思？100？500？301？302？</h4><table>
<thead>
<tr>
<th>Http状态码</th>
<th>Http Status Code</th>
<th>Http状态码含义中文说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>100</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/100">100 Continue</a></td>
<td>请继续请求</td>
</tr>
<tr>
<td><strong>201</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/201">201 Created</a></td>
<td>请求已被接受，等待资源响应</td>
</tr>
<tr>
<td><strong>301</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/301">301 Moved Permanently</a></td>
<td>永久重定向</td>
</tr>
<tr>
<td><strong>302</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/302">302 Found</a></td>
<td>临时重定向</td>
</tr>
<tr>
<td><strong>303</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/303">303 See Other</a></td>
<td>当前请求的资源在其它地址</td>
</tr>
<tr>
<td><strong>304</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/304">304 Not Modified</a></td>
<td>请求资源与本地缓存相同，未修改</td>
</tr>
<tr>
<td><strong>400</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/400">400 Bad Request</a></td>
<td>请求错误，通常是访问的域名未绑定引起</td>
</tr>
<tr>
<td><strong>403</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/403">403 Forbidden</a></td>
<td>禁止访问</td>
</tr>
<tr>
<td><strong>404</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/404">404 Not Found</a></td>
<td>请求的内容未找到或已删除</td>
</tr>
<tr>
<td><strong>405</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/405">405 Method Not Allowed</a></td>
<td>不允许的请求方法</td>
</tr>
<tr>
<td><strong>500</strong></td>
<td><a target="_blank" rel="noopener" href="https://seo.juziseo.com/doc/http_code/500">500 Internal Server Error</a></td>
<td>服务器端程序错误</td>
</tr>
</tbody></table>
<hr>
<h4 id="computed能不能写异步代码？"><a href="#computed能不能写异步代码？" class="headerlink" title="computed能不能写异步代码？"></a>computed能不能写异步代码？</h4><ul>
<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>watch支持异步；</li>
</ul>
<hr>
<h4 id="原生js如何拿到网站的cookie？"><a href="#原生js如何拿到网站的cookie？" class="headerlink" title="原生js如何拿到网站的cookie？"></a>原生js如何拿到网站的cookie？</h4><p>是 <code>document</code> 的属性，也就是 <code>window.document.cookie</code></p>
<hr>
<h4 id="怎么通过原生js获取cookie中的值？"><a href="#怎么通过原生js获取cookie中的值？" class="headerlink" title="怎么通过原生js获取cookie中的值？"></a>怎么通过原生js获取cookie中的值？</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getCookie</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> strcookie <span class="token operator">=</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">;</span><span class="token comment">//获取cookie字符串</span>
    <span class="token keyword">var</span> arrcookie <span class="token operator">=</span> strcookie<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"; "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分割</span>
    <span class="token comment">//遍历匹配</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrcookie<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> arr <span class="token operator">=</span> arrcookie<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">getCookie</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>	<span class="token comment">// 传入键名name，函数返回对应的值</span></code></pre>

<hr>
<h4 id="如何设置cookie的过期时间？"><a href="#如何设置cookie的过期时间？" class="headerlink" title="如何设置cookie的过期时间？"></a>如何设置cookie的过期时间？</h4><p><code>{expires}</code></p>
<p>cookie默认<strong>按天</strong>来算的<code>Cookies.set('name', 'value', { expires: 7 })</code></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 当您希望 cookie 在 15 分钟后过期时</span>
<span class="token keyword">var</span> inFifteenMinutes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">15</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Cookies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">expires</span><span class="token operator">:</span> inFifteenMinutes
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<hr>
<h4 id="render函数与编译模板template有什么区别？"><a href="#render函数与编译模板template有什么区别？" class="headerlink" title="render函数与编译模板template有什么区别？"></a>render函数与编译模板template有什么区别？</h4><ol>
<li>template—-html的方式做渲染</li>
<li>render—-js的方式做渲染</li>
</ol>
<hr>
<h4 id="for…of…"><a href="#for…of…" class="headerlink" title="for…of…"></a>for…of…</h4><ul>
<li><code>for in</code>遍历的是数组的索引（即键名），而<code>for of</code>遍历的是数组元素值。</li>
<li>for of遍历的只是数组内的元素，而<strong>不包括数组的原型属性method和索引name</strong></li>
<li>for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是<strong>不能遍历对象</strong>,因为没有迭代器对象.与forEach()不同的是，它可以<strong>正确响应break、continue和return语句</strong></li>
<li>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法</li>
</ul>
<hr>
<h4 id="Vue开发版本与生产版本的区别"><a href="#Vue开发版本与生产版本的区别" class="headerlink" title="Vue开发版本与生产版本的区别"></a>Vue开发版本与生产版本的区别</h4><p>区别之一在于，使用开发版本时出现“警告”，控制台会有相对应的提示，而生产版本则不会有任何提示</p>
<p>使用了开发版本，打开控制台会出现以下的提示</p>
<hr>
<h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><p>不能用<code>body</code>做为容器</p>
<p>实例化之前是类。</p>
<p><strong>hash模式</strong>：<code>#</code>利用的是锚跳转</p>
<p><strong>路由守卫</strong>：一般使用路由守卫的场景是用户的权限控制，虽然可以使用组件的生命周期完成这个功能，但是使用路由守卫更加高效。因为它的执行比组件的实例化更早，也就是说，只要路由守卫不通过，组件连实例化都不执行。大大的加速控制流程与减少资源的消耗。</p>
<p><strong>函数当成值来用，函数名后面不需要加括号</strong></p>
<p><strong>离散数据：0，1</strong>（性别，学历）</p>
<p><strong>回归数据：0，0.1，0.2，…，1</strong>（年龄，体重）</p>
<hr>
<h4 id="require和import的区别"><a href="#require和import的区别" class="headerlink" title="require和import的区别"></a>require和import的区别</h4><ol>
<li>导入<code>require</code> 导出 <code>exports/module.exports</code> 是 <code>CommonJS</code> 的标准，通常适用范围如 <code>Node.js</code></li>
<li><code>import/export</code> 是 <code>ES6</code> 的标准，通常适用范围如 <code>React</code></li>
<li><code>require</code> 是<strong>赋值过程</strong>并且是<strong>运行时才执行</strong>，也就是<em>同步加载</em></li>
<li><code>require</code> 可以理解为一个全局方法，因为它是一个方法所以意味着可以在任何地方执行。</li>
<li><code>import</code> 是<strong>解构过程</strong>并且是<strong>编译时执行</strong>，理解为<em>异步加载</em></li>
<li><code>import</code> 会提升到整个模块的头部，具有置顶性，但是建议写在文件的顶部。</li>
<li><code>commonjs</code> 输出的，是一个值的拷贝，而<code>es6</code>输出的是值的引用；</li>
<li><code>commonjs</code> 是运行时加载，<code>es6</code>是编译时输出接口；</li>
</ol>
<hr>
<h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p><strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 链式处理,将异步变为类似单线程的写法: 高级用法.</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/some/url'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">.</span> <span class="token comment">//... 执行成功, 第1步...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">returnedValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 执行成功, 第2步...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 中途任何地方出错...在此处理 :( </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><strong>fetch和ajax主要有两种方式不同</strong></p>
<p>从<code>fetch()</code>返回的<code>Promise</code>将不会拒绝<code>http</code>错误状态，即使相应是一个相应是<code>400</code>或者<code>500</code>,它都会按照正常的去解决，并且仅在网络故障时或者任何阻止请求完成时，它才会拒绝，可以做简单的封装。</p>
<hr>
<h4 id="私有成员-静态成员"><a href="#私有成员-静态成员" class="headerlink" title="私有成员|静态成员"></a>私有成员|静态成员</h4><ul>
<li><p>私有成员：</p>
<p>因为js中函数外部无法访问函数内部，所以函数内部就相当于一个私有作用域。定义( var 和 function )在其中的方法和变量就是私有成员。(私有属性和方法不能使用this调用)</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> getA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>静态成员：</p>
<p>函数本身也是对象，所以可以在上定义方法和变量，并且不是在函数的prototype属性中定义的方法和变量，所以无法被函数的实例继承，这就是静态方法和变量。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
fn<span class="token punctuation">.</span><span class="token function-variable function">getA</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
fn<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>特权成员：在构造函数内部用this定义的成员，访问权限和公有成员一样；</p>
</li>
<li><p>公有成员：通过修改构造函数的prototype属性而定义的成员，可以由该构造函数的所有实例访问；</p>
</li>
<li><p>多态：向上转型，多种状态</p>
</li>
</ul>
<hr>
<h4 id="style中的scoped的作用功能"><a href="#style中的scoped的作用功能" class="headerlink" title="style中的scoped的作用功能"></a>style中的scoped的作用功能</h4><p>组件的私有化，不对全局造成样式污染，表示当前style属性只属于当前模块。</p>
<p>从原理可见，之所以scoped可达到类似组件私有化、样式设置”作用域”的效果，其实只是在设置scoped属性的组件上的所有标签添加<strong>data开头的属性</strong>，且在标签选择器的结尾加上和属性相同的字段，起到<strong>唯一性的作用</strong>，但是这样如果组件中也引用其他组件就会出现类似下面的问题：</p>
<ul>
<li>父组件无scoped属性，组组件带有scoped，父组件是无法操作子组件的样式的，虽然我们可以在全局中通过该类标签的标签选择器设置样式，但会影响到其他组件</li>
<li>父组件有scoped属性，子组件没有。父组件也无法设置子组件样式，因为父组件的所有标签都带有data-v-469af010唯一标志，但子组件不会带有这个唯一标志属性，与1同理，虽然我们可以在全局中通过该类标签的标签选择器设置样式，但会影响到其他组件</li>
<li>父子组件都有，同理也无法设置样式，更改起来增加代码质量。</li>
</ul>
<hr>
<h4 id="flex-1有哪些属性？"><a href="#flex-1有哪些属性？" class="headerlink" title="flex:1有哪些属性？"></a>flex:1有哪些属性？</h4><blockquote>
<p>flex：0 1 auto	(后两个属性可选)</p>
</blockquote>
<ul>
<li>flex-grow：属性定义项目的放大比例，默认为<code>0</code></li>
<li>flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间<code>（main size）</code>，它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px）</li>
</ul>
<hr>
<h4 id="display-none与visibility-hidden的区别？"><a href="#display-none与visibility-hidden的区别？" class="headerlink" title="display:none与visibility:hidden的区别？"></a>display:none与visibility:hidden的区别？</h4><ul>
<li><strong>display:none：</strong>该元素以及它的所有后代元素都会隐藏，占据的空间消失。</li>
<li><strong>visibility:hidden：</strong>给元素设置visibility: hidden也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。<ol>
<li>visibility具有<strong>继承性</strong>，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别</li>
<li>visibility: hidden<strong>不会影响计数器的计数</strong>，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样</li>
<li>CSS3的<strong>transition支持visibility属性</strong>，但是并不支持display，由于transition可以延迟执行，因此可以配合visibility使用纯css实现<strong>hover延时显示效果</strong>。提高用户体验。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="判断数组的四种方法："><a href="#判断数组的四种方法：" class="headerlink" title="判断数组的四种方法："></a>判断数组的四种方法：</h4><ol>
<li><p><strong>Array.isArray()判断：</strong>用于确定传递的值是否是一个数组，返回一个布尔值。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span></code></pre>
</li>
<li><p><strong>instanceof判断：</strong>运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
b <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">//false</span></code></pre>
</li>
<li><p><strong>constructor判断：</strong>构造函数属性constructor指向构造函数</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">;</span><span class="token comment">//true</span></code></pre>
</li>
<li><p><strong>Object.prototype.toString.call()判断：</strong>以获取到对象的不同类型</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span><span class="token comment">//true</span></code></pre></li>
</ol>
<hr>
<h4 id="前端大屏幕项目"><a href="#前端大屏幕项目" class="headerlink" title="前端大屏幕项目"></a>前端大屏幕项目</h4><hr>
<h4 id="vue-virtual-scroller"><a href="#vue-virtual-scroller" class="headerlink" title="vue-virtual-scroller"></a>vue-virtual-scroller</h4><p>处理巨量列表的展示。原理是它只把展示给用户的那部分渲染出来，比如滚到上面的 dom 就回收掉。</p>
<hr>
<h4 id="Mock数据"><a href="#Mock数据" class="headerlink" title="Mock数据"></a>Mock数据</h4><p>模拟接口数据。</p>
<hr>
<h4 id="vue-router-常写属性都有什么？"><a href="#vue-router-常写属性都有什么？" class="headerlink" title="vue-router 常写属性都有什么？"></a>vue-router 常写属性都有什么？</h4><p><strong>属性：</strong></p>
<ul>
<li>$router.app ：配置了router的Vue根实例</li>
<li>$router.mode：路由模式，这里是hash</li>
<li>$router.currentRoute：当前路由的路由信息对象，包含了当前匹配路由的信息</li>
</ul>
<p><strong>办法：</strong></p>
<ul>
<li>router.go(n)：接受一个整数作为参数，类似window.history.go(n)，在浏览器历史记录中前进或后退几步</li>
<li>router.push( location )：跳转导航的方法，这种方法会向history栈添加一个新的记录</li>
<li>router.replace( location )：和router.push()类似，但是它会替换掉当前的history记录，不会添加新的记录</li>
<li>router.back()：相当于router.go(-1)</li>
<li>router.forward()：相当于router.go(1)</li>
<li>router.addRoutes(routes)：动态添加路由规则，参数为符合routes选项要求的数组。</li>
<li>路由守卫。</li>
</ul>
<hr>
<h4 id="vue插槽如何使用？"><a href="#vue插槽如何使用？" class="headerlink" title="vue插槽如何使用？"></a>vue插槽如何使用？</h4><blockquote>
<ol>
<li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li>
<li>让使用者可以决定组件内容的一些内容到底展示什么。</li>
</ol>
</blockquote>
<p><strong>抽取共性，保留不同</strong></p>
<ol>
<li>最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。</li>
<li>一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。</li>
<li>是搜索框，还是文字，还是菜单。由调用者自己来决定。</li>
</ol>
<ul>
<li><p><strong>匿名插槽：</strong></p>
<ol>
<li>在子组件中，使用特殊的元素<code>&lt;slot&gt;</code>就可以为子组件开启一个插槽。</li>
<li>该插槽插入什么内容取决于父组件如何使用。</li>
</ol>
</li>
<li><p><strong>具名插槽：</strong></p>
<ol>
<li>非常简单，只要给slot元素一个name属性即可</li>
<li><code>&lt;slot name='myslot'&gt;&lt;/slot&gt;</code></li>
</ol>
</li>
<li><p><strong>作用域插槽：</strong></p>
<p>默认情况下，父组件使用子组件，插槽数据默认是拿父组件的数据，而不是子组件拿数据。<br><strong>作用域插槽</strong>在父组件使用我们的子组件时， 插槽的数据从子组件中拿到数据，而不是从父组件拿到。</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">模板写法
&lt;template #btn="scope"&gt;&lt;/template&gt;</code></pre></li>
</ul>
<hr>
<h4 id="在同步异步中，-let和var的区别。"><a href="#在同步异步中，-let和var的区别。" class="headerlink" title="在同步异步中， let和var的区别。"></a>在同步异步中， let和var的区别。</h4><blockquote>
<p>setTimeout 是异步执行的，1000毫秒后向任务队列里添加一个任务，只有主线上的全部执行完才会执行任务队列里的任务，所以当主线程for循环执行完之后 i 的值为5，这个时候再去任务队列中执行任务，i全部为5；</p>
<p>每次for循环的时候setTimeout都会执行，但是里面的function则不会执行被放入任务队列，因此放了5次；for循环的5次执行完之后不到1000毫秒；</p>
<p>1000毫秒后全部执行任务队列中的函数，所以就是输出五个5啦</p>
</blockquote>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 5 5 5 5 5</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 5</span></code></pre>

<blockquote>
<p>假如把var换成let，那么输出结果为0,1,2,3,4；</p>
<p>因为let  i  的是区块变量，每个i只能存活到大括号结束，并不会把后面的for循环的  i  值赋给前面的setTimeout中的i；而var i  则是局部变量，这个 i 的生命周期不受for循环的大括号限制；</p>
</blockquote>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 0 1 2 3 4 </span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 报错 </span></code></pre>

<hr>
<h4 id="对象的合并"><a href="#对象的合并" class="headerlink" title="对象的合并"></a>对象的合并</h4><ul>
<li><p><strong>Object.assign()</strong></p>
<p>合并对象是将后面的对象合拼到<strong>第一个对象</strong>里面了</p>
<p>会改变第一个的对象，如果不想改变可以给第一个给<strong>空对象</strong></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 给到一个新对象，属于深拷贝</span></code></pre>
</li>
<li><p><strong>…扩展运算符</strong></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"历史"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">gender</span><span class="token operator">:</span> <span class="token string">"男"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">email</span><span class="token operator">:</span> <span class="token string">"cdscds@163.com"</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj1<span class="token punctuation">,</span> <span class="token operator">...</span>obj2 <span class="token punctuation">}</span>	<span class="token comment">// 对象里面都是简单数据类型，扩展运算符相对于深拷贝</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// {name: '张三', gender: '男', email: 'cdscds@163.com'}</span></code></pre></li>
</ul>
<hr>
<h4 id="Vue3的diff对比Vue2的优化部分"><a href="#Vue3的diff对比Vue2的优化部分" class="headerlink" title="Vue3的diff对比Vue2的优化部分"></a>Vue3的diff对比Vue2的优化部分</h4><ul>
<li>vue2：全量 Diff（当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。）；</li>
<li>Vue3：静态标记 + 非全量 Diff（Vue 3在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。）；</li>
</ul>
<hr>
<h4 id="vue-和-react-的diff算法比较"><a href="#vue-和-react-的diff算法比较" class="headerlink" title="vue 和 react 的diff算法比较"></a>vue 和 react 的diff算法比较</h4><ul>
<li><p><strong>vue</strong>的diff算法<br>简单来说，就是vue的diff算法在对新老虚拟DOM进行对比时，是从节点的<strong>两侧向中间对比</strong>；如果节点的key值与元素类型相同，属性值不同，就会认为是不同节点，就会删除重建</p>
</li>
<li><p><strong>react</strong>的diff算法<br>react的diff算法在对新老虚拟dom进行对比是，是从<strong>节点左侧开始对比</strong>，就好比将新老虚拟dom放入两个栈中，一对多依次对比；如果节点的key值与元素类型相同，属性值不同，react会认为是同类型节点，只是修改节点属性</p>
</li>
</ul>
<hr>
<h4 id="前端模块化的理解？前端自动化构建工具？"><a href="#前端模块化的理解？前端自动化构建工具？" class="headerlink" title="前端模块化的理解？前端自动化构建工具？"></a>前端模块化的理解？前端自动化构建工具？</h4><ul>
<li><p>前端自动化构建工具：<strong>webpack、gulp</strong></p>
</li>
<li><p>前端模块化的理解：</p>
<blockquote>
<p>我们要写一个实现A功能的JS代码,这个功能在项目其他位置也需要用到,那么我们就可以把这个功能看成一个模块采用一定的方式进行模块化编写,既能实现复用还可以分而治之,同理在写样式的时候,如果我们需要某种特殊的样式,会在很多地方应用,那么我们也可以采用一定的方式进行CSS的模块化</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="Vue，react，angular的区别"><a href="#Vue，react，angular的区别" class="headerlink" title="Vue，react，angular的区别"></a>Vue，react，angular的区别</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Berlin_Rome/article/details/94390941">Vue，react，angular的区别</a></p>
<hr>
<h4 id="css隐藏元素的几种方法"><a href="#css隐藏元素的几种方法" class="headerlink" title="css隐藏元素的几种方法"></a>css隐藏元素的几种方法</h4><ul>
<li>overflow:hidden</li>
<li>opacity:0；</li>
<li>visibility:hidden</li>
<li>display:none</li>
<li>position:absolute</li>
<li>clip(clip-path):rect()/inset()/polygon()</li>
<li>z-index:-1000</li>
<li>transform:scaleY(0)</li>
<li>height和width属性为0</li>
</ul>
<hr>
<h4 id="什么是语义化的HTML"><a href="#什么是语义化的HTML" class="headerlink" title="什么是语义化的HTML"></a>什么是语义化的HTML</h4><blockquote>
<p>语义化的HTML就是<strong>正确的标签做正确的事情</strong>，能够便于开发者阅读和写出更优雅的代码的同时让网络爬虫很好地解析。</p>
</blockquote>
<p><strong>为什么要做到语义化？</strong></p>
<p>1、有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。</p>
<p>2、在没有CSS的时候能够清晰的看出网页的结构，增强可读性。</p>
<p>3、便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力。</p>
<p>4、支持多终端设备的浏览器渲染。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">&gt;</span></span>	标题，logo，slogan；包裹目录部分，搜索框，一个nav或者任何相关的logo；
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">&gt;</span></span>	定义文章导航栏，链接等;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">&gt;</span></span>	定义文章的主要内容；
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span><span class="token punctuation">&gt;</span></span>	定义文档中可以脱离其他部分，一份独立的内容，通常带有标题，
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">&gt;</span></span>	它是整体的一部分，或者是文章的一节
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aside</span><span class="token punctuation">&gt;</span></span>		侧边栏（与article并列存在）或者嵌入内容（在article内）
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">&gt;</span></span>	页脚，通常包含作者、版权信息或者相关链接等；</code></pre>

<hr>
<h4 id="CSS-水平居中和垂直居中的方法-分内联元素和块级元素"><a href="#CSS-水平居中和垂直居中的方法-分内联元素和块级元素" class="headerlink" title="CSS 水平居中和垂直居中的方法(分内联元素和块级元素)"></a>CSS 水平居中和垂直居中的方法(分内联元素和块级元素)</h4><p><strong>水平居中：</strong> </p>
<ul>
<li><p><strong>内联元素：</strong></p>
<ul>
<li>父元素设置为块级元素，再给父元素设置 <strong>text-align: center;</strong></li>
</ul>
</li>
<li><p><strong>块级元素：</strong></p>
<ul>
<li><p><strong>定宽度：</strong>需要谁居中，给其设置 <strong>margin: 0 auto;</strong> （作用：使盒子自己居中）</p>
</li>
<li><p><strong>不定宽度：</strong>转换成行内块级/行内元素，给父元素设置 <strong>text-align: center;</strong> </p>
</li>
<li><p><strong>使用定位属性：</strong></p>
<p>​	<strong>定宽度：</strong>子绝父相，子元素的<strong>left:50%<strong>，</strong>margin-left: -元素宽度的一半px;</strong></p>
<p>​	<strong>不定宽度：</strong><code>transform: translateX(-50%);</code></p>
</li>
<li><p><strong>flex布局：</strong>父元素添加属性 <strong>display: flex; justify-content: center;</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>垂直居中：</strong></p>
<ul>
<li><p><strong>内联元素：</strong></p>
<ul>
<li><strong>单行的行内元素：</strong>行高等于盒子的高</li>
<li><strong>多行的行内元素：</strong>父元素设置<code>display:table-cell;</code>和<code>vertical-align: middle;</code></li>
</ul>
</li>
<li><p><strong>块级元素：</strong></p>
<ul>
<li><p><strong>使用定位属性：</strong></p>
<ul>
<li><p><strong>定宽度：</strong>子绝父相，子元素的**top: 50%**，绝对子元素的 <strong>margin-top: -元素高度的一半	px;</strong></p>
</li>
<li><p><strong>不定宽度：</strong><code>transform: translateY(-50%);</code></p>
</li>
</ul>
</li>
<li><p><strong>flex布局：</strong>父元素添加属性 <strong>display: flex; align-items: center;</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>水平垂直居中：</strong></p>
<ul>
<li><strong>已知高度和宽度的元素：</strong><ul>
<li>子绝父相，<strong>top: 0; right: 0; bottom: 0; left: 0; margin: auto;</strong></li>
<li>子绝父相，<strong>left: 50%; top: 50%; margin-left: –元素宽度的一半px; margin-top: –元素高度的一半px;</strong></li>
</ul>
</li>
<li><strong>未知高度和宽度的元素：</strong><ul>
<li><strong>使用定位属性：</strong>子绝父相，<strong>left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);</strong></li>
<li><strong>使用flex布局实现：</strong>justify-content: center; align-items: center;</li>
</ul>
</li>
</ul>
<hr>
<h4 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gg-qq/p/11399152.html">使用场景</a></p>
<p>闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<ul>
<li><p>典型应用是模块封装，防止变量污染全局。</p>
</li>
<li><p>在循环中创建闭包，防止取到意外的值。</p>
</li>
<li><p>setTimeout：</p>
<p>　　原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果。</p>
</li>
<li><p>回调：</p>
<p>　　定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码通常会作为一个回调（事件触发时调用的函数）绑定到事件。</p>
</li>
<li><p>函数防抖：</p>
<p>​		实现的关键就在于<code>setTimeOut</code>这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现。</p>
</li>
<li><p>封装私有变量</p>
</li>
</ul>
<hr>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>​			事件代理，原理就是<strong>利用事件冒泡特点</strong>：当子元素的事件发生时，父元素的同名事件也会发生——指定一个事件处理程序,就可以管理某一类型的所有事件。</p>
<p><strong>优点：</strong>不用给列表的每一个元素绑定事件，只需要<strong>绑定父元素</strong>就可以处理所有子元素的事件，优化性能。</p>
<hr>
<h4 id="写一个深度复制数组或者对象的函数"><a href="#写一个深度复制数组或者对象的函数" class="headerlink" title="写一个深度复制数组或者对象的函数"></a>写一个深度复制数组或者对象的函数</h4><p><strong>递归 + 类型判断</strong></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">copyLinearArray</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> sourceCopy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        objectCopy <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果是对象</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> source<span class="token punctuation">)</span> objectCopy<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token operator">?</span> <span class="token function">copyLinearArray</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> source<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> objectCopy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//如果是其他数组</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sourceCopy<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token operator">?</span> <span class="token function">copyLinearArray</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> source<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sourceCopy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<hr>
<h4 id="在react中遍历生成元素有哪些方法"><a href="#在react中遍历生成元素有哪些方法" class="headerlink" title="在react中遍历生成元素有哪些方法"></a>在react中遍历生成元素有哪些方法</h4><ul>
<li><code>React.Children.map</code>和 <code>React.Children.forEach</code>这两个方法</li>
</ul>
<hr>
<h4 id="在react中页面重新加载时怎么保留数据"><a href="#在react中页面重新加载时怎么保留数据" class="headerlink" title="在react中页面重新加载时怎么保留数据"></a>在react中页面重新加载时怎么保留数据</h4><ul>
<li><strong>Redux：</strong> 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；</li>
<li><strong>localstorage</strong></li>
</ul>
<hr>
<h4 id="前端异常捕获"><a href="#前端异常捕获" class="headerlink" title="前端异常捕获"></a>前端异常捕获</h4><ul>
<li><strong>try…catch…</strong></li>
<li><strong>window.onerror</strong>无法捕获跨域资源出现的异常和webpack打包压缩文件时生成的source-map</li>
</ul>
<hr>
<h4 id="ajax的基本流程"><a href="#ajax的基本流程" class="headerlink" title="ajax的基本流程"></a>ajax的基本流程</h4><ul>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象。</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息。</li>
<li>设置响应HTTP请求状态变化的函数。</li>
<li>发送HTTP请求。</li>
<li>获取异步调用返回的数据。</li>
<li>使用JavaScript和DOM实现局部刷新。</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">-</span> 收到一个新的快递
<span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'Methor'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">-</span> 你迫不及待地打开
<span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">-</span> 发现你的东西有问题，就给送回去了
<span class="token keyword">function</span> <span class="token function">onload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">-</span> 卖家处理你的快递
responseText <span class="token operator">--</span><span class="token operator">-</span> 处理后，再把快递给你返回来</code></pre>

<hr>
<h4 id="npm，yarn的区别"><a href="#npm，yarn的区别" class="headerlink" title="npm，yarn的区别"></a>npm，yarn的区别</h4><ul>
<li><strong>yarn：</strong><ul>
<li>速度快</li>
<li>安装版本统一</li>
<li>输出简洁</li>
<li>多注册来源处理</li>
</ul>
</li>
<li><strong>npm ：</strong><ul>
<li>下载速度慢。</li>
<li>同一个项目，<strong>安装的无法保持一致性</strong>。</li>
<li>一大堆提示信息中丢失掉错误信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="媒体查询是css3新增根据屏幕宽度去修改css样式的功能"><a href="#媒体查询是css3新增根据屏幕宽度去修改css样式的功能" class="headerlink" title="媒体查询是css3新增根据屏幕宽度去修改css样式的功能"></a>媒体查询是css3新增根据屏幕宽度去修改css样式的功能</h4><hr>
<h4 id="微信支付流程"><a href="#微信支付流程" class="headerlink" title="微信支付流程"></a>微信支付流程</h4><ul>
<li>打开某小程序，点击直接下单</li>
<li>wx.login获取用户临时登录凭证code，发送到后端服务器换取openId</li>
<li>在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器</li>
<li>服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息</li>
<li>小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付</li>
<li>接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付</li>
<li>鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示</li>
<li>推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态</li>
</ul>
<hr>
<h4 id="cookie-和-localStorage-大小"><a href="#cookie-和-localStorage-大小" class="headerlink" title="cookie 和 localStorage 大小"></a>cookie 和 localStorage 大小</h4><ul>
<li>cookie ：4K；</li>
<li>localStorage ：5M</li>
</ul>
<hr>
<h4 id="transform-transition-animation"><a href="#transform-transition-animation" class="headerlink" title="transform, transition, animation"></a>transform, transition, animation</h4><ul>
<li><strong>transform 描述了元素静态样式。</strong></li>
<li><strong>transition 和 animation 却都能实现动画效果。</strong></li>
<li><strong>transform 常常配合后两者使用</strong></li>
</ul>
<hr>
<h4 id="单行文本超出省略"><a href="#单行文本超出省略" class="headerlink" title="单行文本超出省略"></a>单行文本超出省略</h4><pre class="language-css" data-language="css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span>ellipsis<span class="token punctuation">;</span>
<span class="token property">white-space</span><span class="token punctuation">:</span>nowrap</code></pre>

<p><strong>多行</strong></p>
<pre class="language-css" data-language="css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
<span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span> 	将对象作为弹性伸缩盒子模型显示 。
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span>	用来限制在一个块元素显示的文本的行数
<span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>	设置或检索伸缩盒对象的子元素的排列方式 。</code></pre>

<hr>
<h4 id="const-对象的值为什么可以改变"><a href="#const-对象的值为什么可以改变" class="headerlink" title="const 对象的值为什么可以改变"></a>const 对象的值为什么可以改变</h4><p>因为对象是引用类型的，P中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。<strong>也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。</strong></p>
<hr>
<h4 id="箭头函数为什么不能new"><a href="#箭头函数为什么不能new" class="headerlink" title="箭头函数为什么不能new"></a>箭头函数为什么不能new</h4><p>因为箭头函数没有自己的 this 变量，我们就没有办法修改 this 的指向，所以也不可以将其作为构造函数、它也没有 prototype 对象。</p>
<hr>
<h4 id="判断一个对象是否为空对象"><a href="#判断一个对象是否为空对象" class="headerlink" title="判断一个对象是否为空对象"></a>判断一个对象是否为空对象</h4><ul>
<li><p>for…in…遍历属性</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果不为空，则会执行到这一步，返回true</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// 如果为空,返回false</span></code></pre>
</li>
<li><p>通过JSON自带的<code>stringify()</code>方法来判断</p>
</li>
<li><p>Object.keys()</p>
</li>
</ul>
<hr>
<h4 id="判断一个对象是否为空数组"><a href="#判断一个对象是否为空数组" class="headerlink" title="判断一个对象是否为空数组"></a>判断一个对象是否为空数组</h4><ul>
<li>数组长度</li>
<li>数组===false</li>
</ul>
<hr>
<h4 id="interface与class的区别"><a href="#interface与class的区别" class="headerlink" title="interface与class的区别"></a>interface与class的区别</h4><ul>
<li><p><strong>interface:接口只声明成员方法，不做实现。</strong></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lng</span><span class="token operator">:</span>number<span class="token punctuation">;</span>
    <span class="token literal-property property">lat</span><span class="token operator">:</span>number<span class="token punctuation">;</span>
    <span class="token function">sayPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p><strong>class:类声明并实现方法。</strong></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">lng<span class="token punctuation">,</span>lat</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lng <span class="token operator">=</span> lng<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lat <span class="token operator">=</span> lat<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sayPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'point:'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>lng<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>lat<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p><strong>extends 与 implement</strong></p>
<ul>
<li><p>extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承。</p>
<blockquote>
<p>extends可以继承父类的方法，也可以重写他，但是要注意的是，如果父类是抽象类，内部有抽象的方法，子类在extends的时候，如果子类不是抽象类，那么子类就一定要对父类中的抽象方法进行重写。但如果子类也是抽象类，则可以不可考虑重写。extends支持子类，孙类……即可以继承多代。</p>
</blockquote>
</li>
<li><p>继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">C</span><span class="token punctuation">,</span><span class="token constant">D</span><span class="token punctuation">,</span><span class="token constant">E</span>
  <span class="token comment">// C,D,E 是interface类型的，且他的里面的方法都是abstract类型的方法。</span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Axios-取消请求-应用场景"><a href="#Axios-取消请求-应用场景" class="headerlink" title="Axios 取消请求 应用场景"></a>Axios 取消请求 应用场景</h4><ol>
<li>如果一个数据请求量比较大（可能会请求错误），还没请求完就<strong>切换路由</strong>，可能会出现错误的提示框（响应拦截器中配置错误提示）</li>
<li>导出文件或下载文件时，<strong>中途取消</strong></li>
<li>一个请求请求量比较大，发送新请求时需要<strong>取消上一个请求</strong></li>
</ol>
<hr>
<h4 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h4><ul>
<li>骨架屏</li>
<li>路由图片懒加载</li>
<li>预渲染<code>prerender</code>插件</li>
<li>SSR</li>
<li>传输压缩(Gzip)</li>
<li>浏览器缓存</li>
</ul>
<hr>
<h4 id="移动端点击事件延迟300ms"><a href="#移动端点击事件延迟300ms" class="headerlink" title="移动端点击事件延迟300ms"></a>移动端点击事件延迟300ms</h4><ul>
<li><p>tap事件,也是轻击、轻触事件</p>
</li>
<li><p>静止缩放</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width user-scalable= 'no'"</span><span class="token operator">&gt;</span></code></pre>
</li>
<li><p>fastclick库</p>
</li>
</ul>
<hr>
<h4 id="单页面应用滚动条记忆"><a href="#单页面应用滚动条记忆" class="headerlink" title="单页面应用滚动条记忆"></a>单页面应用滚动条记忆</h4><ul>
<li>官方：<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html#%E5%BC%82%E6%AD%A5%E6%BB%9A%E5%8A%A8"> scrollBehavior </a>方法<strong>这个功能只在支持 <code>history.pushState</code> 的浏览器中可用。</strong></li>
<li>可以利用组件内守卫，记录离开时的位置，进入时，通过获取滚动条位置。</li>
</ul>
<hr>
<h4 id="iframe-内嵌框架有那些缺点-？"><a href="#iframe-内嵌框架有那些缺点-？" class="headerlink" title="iframe 内嵌框架有那些缺点 ？"></a>iframe 内嵌框架有那些缺点 ？</h4><p>内联框架 iframe 一般用来包含别的页面，例如 我们可以在我们自己的网站页面加载别人网站的内容，为了更好的效果，可能需要使 iframe 透明效果；</p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO 搜索引擎优化（Search Engine Optimization）</li>
<li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
</ul>
<p>如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。</p>
<hr>
<h4 id="使用var声明的变量-和-直接赋值并未声明的变量的区别"><a href="#使用var声明的变量-和-直接赋值并未声明的变量的区别" class="headerlink" title="使用var声明的变量 和 直接赋值并未声明的变量的区别"></a>使用var声明的变量 和 直接赋值并未声明的变量的区别</h4><ul>
<li><p>在函数作用域内 加var定义的变量是局部变量，不加var定义的就成了全局变量。<br>使用var定义</p>
</li>
<li><p>在全局作用域下，使用var定义的变量不可以delete,没有var 定义的变量可以delete.</p>
<p>也就说明隐含全局变量严格来说不是真正的变量，而是全局对象的属性，因为属性可以通过delete删除，而变量不可以。</p>
</li>
<li><p>使用var 定义变量还会提升变量声明</p>
</li>
</ul>
<hr>
<h4 id="布局有那些？"><a href="#布局有那些？" class="headerlink" title="布局有那些？"></a>布局有那些？</h4><p><img src="/2022/08/05/interview/%E5%B8%83%E5%B1%80-1665214708504.png" alt="布局"></p>
<p><strong>自适应：检测视口分辨率，返回不同的页面：自适应布局需要开发多套界面</strong></p>
<p><strong>响应式：需要开发一套界面就可以了</strong></p>
<hr>
<h4 id="页面实现字体大小10px"><a href="#页面实现字体大小10px" class="headerlink" title="页面实现字体大小10px"></a>页面实现字体大小10px</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">.</span>font10px <span class="token punctuation">{</span>
    font<span class="token operator">-</span>size<span class="token operator">:</span> 12px<span class="token punctuation">;</span>
    <span class="token literal-property property">transform</span> <span class="token operator">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0.83</span><span class="token punctuation">,</span><span class="token number">0.83</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<hr>
<h4 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h4><ul>
<li><p>transition是<strong>过渡属性</strong>，强调过渡，他的实现需要触发一个事件;过渡只有一组（两个：开始-结束）关键帧。</p>
</li>
<li><p>animation是<strong>动画属性</strong>，他的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画（设置多个关键帧）。</p>
<blockquote>
<p>animation-fill-mode:forwards这个属性可以在动画完成后将动画最后的状态应用到元素上</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="v-model的原理简单描述"><a href="#v-model的原理简单描述" class="headerlink" title="v-model的原理简单描述"></a>v-model的原理简单描述</h4><p>语法糖，<strong>v-model 可以用 value 属性和input事件来代替</strong></p>
<p><strong>双向数据绑定的原理</strong></p>
<hr>
<h4 id="vue-过滤器的理解"><a href="#vue-过滤器的理解" class="headerlink" title="vue 过滤器的理解"></a>vue 过滤器的理解</h4><ol>
<li>过滤器的作用:用于文本格式化,仅仅作为格式化操作,不做复杂的业务处理</li>
<li>过滤器的使用方式:通过管道符号(|)来使用</li>
<li>过滤器的使用位置:mustache插值和v-bing的表达式</li>
</ol>
<hr>
<h4 id="dist文件夹"><a href="#dist文件夹" class="headerlink" title="dist文件夹"></a>dist文件夹</h4><p><strong>给服务器用的最终发布版本。</strong></p>
<pre class="language-js" data-language="js"><code class="language-js">css文件夹下的<span class="token punctuation">.</span>css文件是项目要用到的css文件<span class="token punctuation">,</span>当你做webpack打包的时候，会把所有的css样式打包到这里
css文件夹下的<span class="token punctuation">.</span>css<span class="token punctuation">.</span>map文件是一个Source map文件，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。目的是帮助我们调试被压缩过的css代码，只是方便我们开发的时候做调试使用。
js文件夹下的<span class="token punctuation">.</span>js<span class="token punctuation">.</span>map依然是Source map文件，方便我们开发时调试js代码使用。
app<span class="token punctuation">.</span>js文件里放的是项目中各个页面的逻辑代码
manifest<span class="token punctuation">.</span>js文件可以理解为webpack打包生成的一个配置文件，我们一般不需要关心它
vendor<span class="token punctuation">.</span>js放的是各个页面各个组件公用的一些代码
index<span class="token punctuation">.</span>html使我们前端代码入口的一个html文件</code></pre>

<hr>
<h4 id="axios中断请求"><a href="#axios中断请求" class="headerlink" title="axios中断请求"></a>axios中断请求</h4><ul>
<li>CancelToken ；</li>
<li>AbortController；</li>
</ul>
<hr>
<h4 id="微信扫码登录流程"><a href="#微信扫码登录流程" class="headerlink" title="微信扫码登录流程"></a>微信扫码登录流程</h4><p><img src="/2022/08/05/interview/2015b5775f4a8e08030dffde6862766d.jpeg" alt="微信扫码登录流程"></p>
<hr>
<h4 id="项目中的产生的错误怎么监听和处理"><a href="#项目中的产生的错误怎么监听和处理" class="headerlink" title="项目中的产生的错误怎么监听和处理"></a>项目中的产生的错误怎么监听和处理</h4><ul>
<li>try catch</li>
<li>Promise.catch()</li>
<li>window.onerror</li>
<li>window.addEventListener(‘error’,(error)=&gt;{console.log(error)})</li>
</ul>
<hr>
<h4 id="webpack的优化"><a href="#webpack的优化" class="headerlink" title="webpack的优化"></a>webpack的优化</h4><ul>
<li><p>优化loader配置：test、include、exclude属性来匹配文件，三个配置项来缩⼩loader的处理范围</p>
</li>
<li><p>压缩CSS和HTML</p>
</li>
<li><p>tree shaking</p>
</li>
<li><p>作⽤域提升（Scope Hoisting）分析出模块之间的依赖关系，尽可能地把模块放到同⼀个函数中</p>
</li>
<li><p>代码分割</p>
<pre class="language-js" data-language="js"><code class="language-js">项目包含第三方依赖库以及自己写的代码，打包出的文件会比较大，在用户访问系统的时候，由于请求的资源比较大，所以会响应的比较慢，造成页面渲染缓慢，影响用户体验。
代码分割以后，chunk会相应的变小，用户访问时，只需返回此页面相关chunk，再加上浏览器的并行请求策略，从而加快系统响应速度，优化用户体验。</code></pre></li>
</ul>
<hr>
<h4 id="冒泡排序和快速排序"><a href="#冒泡排序和快速排序" class="headerlink" title="冒泡排序和快速排序"></a>冒泡排序和快速排序</h4><ul>
<li>冒泡排序：<strong>相邻两个数进行比较，符合条件的情况下交换位置</strong></li>
<li>快速排序：<ul>
<li>找出数组的中间值，取出来，改变了原数组；</li>
<li>将已经改变之后的数组进行循环遍历和这个取出来的中间值进行比较，小于中间值的 都统一打包放在一个数组中(l),反之放在另外一个数组中(r) [l mid r]最后将这些数组进行合并得到一个新的数组。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="赋值、浅拷贝、深拷贝"><a href="#赋值、浅拷贝、深拷贝" class="headerlink" title="赋值、浅拷贝、深拷贝"></a>赋值、浅拷贝、深拷贝</h4><p><img src="/2022/08/05/interview/image-20221008205923949.png" alt="image-20221008205923949"></p>
<hr>
<h4 id="rem-和-rpx"><a href="#rem-和-rpx" class="headerlink" title="rem 和 rpx"></a>rem 和 rpx</h4><ul>
<li><p><strong>rem（移动端）</strong></p>
<blockquote>
<p>一般浏览器默认(1rem=16px);</p>
<p>例如：设计稿750px宽度，那么1rem = （750/20）rpx = 37.5px<br>例如：设计稿640px宽度，那么1rem = （640/20）rpx = 32px</p>
<ol>
<li><p>使用媒体查询，根据不同设备按比例设置html文字大小，然后页面元素使用rem作为尺寸单位，当html大小改变时，元素也会发生改变，从而达到等比缩放的适配</p>
</li>
<li><p>①页面元素的rem值 = 页面元素值（px） / （屏幕宽度  /  划分的份数）</p>
</li>
</ol>
<p>  ②屏幕宽度 / 划分的份数就是 html font-size(根字号) 的大小</p>
<p>  <strong>以750的尺寸为例，把屏幕划分为15等份，那么html根字号的大小就是750/15=50px。rem就是元素的px/根子号。100px的宽度就等于100/50=2rem</strong></p>
</blockquote>
</li>
<li><p><strong>rpx（uni-app和微信小程序）</strong></p>
<blockquote>
<p>uni-app 规定屏幕基准宽度 750rpx。</p>
<p><strong>例如</strong>：设计稿750px宽度，ps上量出或者标出的宽度是多少，那么就定义多少rpx，也就是，1px = 1rpx<br><strong>例如</strong>：设计稿640px宽度，根据量出的或者标出的尺寸需要转换一下，1px = 750/640rpx</p>
<p>公式：  750 * (元素在设计稿中的宽度 / 设计稿主体宽度)</p>
<pre class="language-js" data-language="js"><code class="language-js">设计稿主体的宽度是 375px<span class="token punctuation">;</span>
设计稿中一个组件的的宽度是 330px<span class="token punctuation">;</span>
<span class="token number">750</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">330</span><span class="token operator">/</span><span class="token number">375</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">660</span> rpx<span class="token punctuation">;</span></code></pre></blockquote>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Evedward</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hellozhj.github.io/2022/08/05/interview/">https://hellozhj.github.io/2022/08/05/interview/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Evedward</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/08/07/wei-xin-xiao-cheng-xu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="微信小程序">
                        
                        <span class="card-title">微信小程序</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-08-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Evedward
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
                        <span class="chip bg-color">小程序</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/07/24/vue2-xiang-mu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="vue2项目">
                        
                        <span class="card-title">vue2项目</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-07-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Evedward
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/vue/">
                        <span class="chip bg-color">vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">Evedward</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">216.7k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/hellozhj" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wymail@126.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2325910627" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2325910627" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
